<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>OSM Data Explorer</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <!-- Font Awesome + Awesome Markers -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.css"/>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    #map { height: 100vh; width: 100%; z-index: 0; }
    .search-panel {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      z-index: 1000; max-width: 64rem; width: 90%; max-height: 90vh; overflow-y: auto;
    }
    .loading-overlay {
      position: absolute; inset: 0; background: rgba(0,0,0,.2); backdrop-filter: blur(4px);
      display: flex; align-items: center; justify-content: center; z-index: 2000;
    }
    .spinner {
      border: 4px solid #f3f3f3; border-top: 4px solid #6366f1; border-radius: 50%;
      width: 48px; height: 48px; animation: spin 1s linear infinite;
    }
    @keyframes spin { 0% { transform: rotate(0deg) } 100% { transform: rotate(360deg) } }
    .hidden { display: none }
    .leaflet-popup-content-wrapper { border-radius: 12px }

    .progress-bar { height: 8px; background: #e5e7eb; border-radius: 8px; overflow: hidden; }
    .progress-bar > div { height: 100%; background: linear-gradient(90deg, #22c55e, #3b82f6); width: 0%; transition: width .2s ease; }

    /* Modal base */
    .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,.35); backdrop-filter: blur(2px); display: flex; align-items: center; justify-content: center; z-index: 4000; }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-gray-50 via-white to-blue-50">
  <!-- Header -->
  <header class="bg-gradient-to-r from-indigo-600 via-purple-600 to-pink-600 text-white shadow-2xl p-6 md:p-8 relative z-10">
    <div class="max-w-7xl mx-auto text-center md:text-left">
      <h1 class="text-3xl md:text-5xl font-black mb-2 drop-shadow-lg">🌍 OSM Data Explorer</h1>
      <p class="text-lg md:text-xl opacity-95 max-w-3xl mx-auto md:mx-0 leading-relaxed">
        Décrivez ce que vous voulez voir (points, lignes, réseaux) et regardez-le apparaître sur la carte.
      </p>
      <p class="text-sm md:text-base mt-4 opacity-80 italic">
        Données en temps réel via Overpass. Le zoom s'ajuste automatiquement.
      </p>
    </div>
  </header>

  <!-- Bouton Nouvelle Recherche -->
  <button id="newSearchButton"
          class="hidden absolute top-28 left-4 z-[1000] bg-white/90 backdrop-blur-md shadow-lg rounded-lg p-3 text-gray-700 font-semibold hover:bg-gray-50 transition-transform hover:scale-105">
    <i class="fa-solid fa-magnifying-glass mr-2"></i> Nouvelle Recherche
  </button>

  <!-- Map -->
  <div id="map"></div>

  <!-- Search Panel -->
  <div class="search-panel">
    <div class="bg-white/95 backdrop-blur-xl rounded-3xl shadow-2xl border border-white/50 p-6 md:p-8">
      <div class="space-y-6">
        <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-3">
          <label class="block text-gray-800 text-xl font-bold">
            🔍 Que voulez-vous explorer?
          </label>
          <!-- Dictionnaire des macros -->
          <button id="openMacroDocs"
                  class="inline-flex items-center gap-2 px-3 py-2 rounded-lg bg-white/80 border border-gray-200 text-gray-700 hover:bg-white hover:shadow">
            <i class="fa-solid fa-book-open"></i> Dictionnaire des macros
          </button>
        </div>
        <input id="searchInput" type="text"
               value="transport:bus et mobilites_douces in Lyon"
               class="w-full px-6 py-4 text-lg bg-gradient-to-r from-gray-50 to-blue-50 border-2 border-gray-300 rounded-2xl focus:outline-none focus:ring-4 focus:ring-indigo-500 focus:border-transparent shadow-xl transition-all duration-300 placeholder-gray-500 font-medium"
               placeholder="Ex: transport:bus in Paris, mobilites_douces and eau in Marseille, zone commerciale in Nantes"/>

        <button id="searchButton"
                class="w-full py-4 px-8 bg-gradient-to-r from-emerald-500 via-teal-500 to-cyan-500 text-white font-extrabold text-lg rounded-2xl shadow-2xl hover:shadow-3xl transform hover:scale-105 active:scale-95 transition-all duration-300 flex items-center justify-center gap-3 uppercase tracking-wide">
          🚀 Lancer la recherche
        </button>

        <div id="errorDisplay" class="hidden p-6 bg-gradient-to-r from-red-50 to-pink-50 border-2 border-red-200 rounded-2xl shadow-md">
          <div class="flex items-center gap-3 mb-2">
            <span class="text-2xl">⚠️</span>
            <h3 class="font-bold text-red-800 text-lg">Problème de requête</h3>
          </div>
          <p id="errorMessage" class="text-red-700 leading-relaxed whitespace-pre-wrap"></p>
        </div>

        <!-- Aide -->
        <div class="p-4 bg-blue-50/50 border border-blue-200 rounded-2xl text-sm md:text-base space-y-2">
          <p class="font-semibold text-blue-800 flex items-center gap-2">📋 Sujets supportés (combinez-les!)</p>
          <p class="text-blue-700">
            Points: stop (arrêts bus), school, university, restaurant, cafe, bar, park, hospital, clinic, shop, atm, bank, hotel, fountain, swimming_pool
          </p>
          <p class="text-blue-700">
            Lignes/Surfaces: cycleway, footway, sidewalk, path, pedestrian, river, stream, canal, drain, ditch, wetlands, lake, pond, reservoir, basin
          </p>
          <p class="text-blue-700">
            Macros: eau, transport, résidentiel (zone résidentielle), commercial (zone commerciale), industriel, végétation, mobilites_douces
          </p>
          <p class="text-blue-700">
            Sous-macros: transport:bus | transport:tram | transport:subway | transport:rail | transport:aerial
          </p>
          <p class="text-gray-600 text-xs italic">“and” ou “et” fonctionnent. Ex: transport:bus et mobilites_douces in Lyon.</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Results Counter -->
  <div id="resultsCounter" class="hidden absolute bottom-6 right-6 z-30">
    <div class="bg-white/95 backdrop-blur-xl rounded-2xl shadow-2xl p-4 md:p-6 border border-gray-200/50 space-y-3 min-w-[220px]">
      <div class="flex items-center justify-between gap-2 mb-3">
        <span class="text-2xl font-bold text-green-600">🎯</span>
        <span id="resultCount" class="text-lg font-bold text-gray-800">0</span>
        <span class="text-sm text-gray-600">éléments</span>
      </div>
      <button id="fitButton"
              class="w-full py-3 px-4 bg-gradient-to-r from-blue-500 to-indigo-600 text-white font-semibold rounded-xl shadow-lg hover:shadow-xl transform hover:scale-105 transition-all duration-200 flex items-center justify-center gap-2 text-sm uppercase tracking-wide">
        📐 Ajuster aux éléments
      </button>
    </div>
  </div>

  <!-- Analyse Gaps Panel (déjà enrichi) -->
  <div id="analysisPanel" class="hidden absolute bottom-6 left-6 z-30">
    <div class="bg-white/95 backdrop-blur-xl rounded-2xl shadow-2xl p-4 md:p-5 border border-gray-200/50 space-y-3 min-w-[340px]">
      <div class="flex items-center gap-2">
        <span class="text-xl">🕳️</span>
        <h3 class="font-bold text-gray-800">Gaps réseau cyclable</h3>
      </div>

      <div class="grid grid-cols-3 gap-3 text-sm">
        <label class="flex flex-col">
          <span class="text-gray-700">Seuil connexion (m)</span>
          <input id="joinThreshold" type="number" min="1" value="15" class="mt-1 px-2 py-1 border rounded-md"/>
        </label>
        <label class="flex flex-col">
          <span class="text-gray-700">Rayon gap max (m)</span>
          <input id="gapRadius" type="number" min="10" value="120" class="mt-1 px-2 py-1 border rounded-md"/>
        </label>
        <label class="flex flex-col">
          <span class="text-gray-700">Résolution (m)</span>
          <input id="sampleResolution" type="number" min="10" max="200" value="50" class="mt-1 px-2 py-1 border rounded-md"/>
        </label>
      </div>

      <div class="flex items-center gap-2 text-sm mt-1">
        <input id="includeBusLanes" type="checkbox" class="w-4 h-4">
        <label for="includeBusLanes" class="text-gray-700">Inclure les voies bus</label>
      </div>

      <button id="advancedSettingsToggle"
              class="w-full py-2 px-4 bg-gradient-to-r from-gray-600 to-gray-800 text-white font-semibold rounded-xl shadow hover:shadow-md transition flex items-center justify-center gap-2">
        <i class="fa-solid fa-sliders"></i> Paramètres avancés
      </button>
      <div id="advancedPanel" class="hidden p-3 bg-gray-50 border border-gray-200 rounded-xl space-y-3">
        <div class="grid grid-cols-2 gap-3 text-sm">
          <label class="flex flex-col">
            <span>Espacement candidats (m)</span>
            <input id="advCandidateSpacing" type="number" min="20" step="10" value="120" class="mt-1 px-2 py-1 border rounded-md"/>
          </label>
          <label class="flex flex-col">
            <span>Max nœuds internes</span>
            <input id="advMaxInternalPerComp" type="number" min="10" step="5" value="60" class="mt-1 px-2 py-1 border rounded-md"/>
          </label>
          <label class="flex flex-col">
            <span>Cap extrémités</span>
            <input id="advCapEndpoints" type="number" min="10" step="5" value="80" class="mt-1 px-2 py-1 border rounded-md"/>
          </label>
          <label class="flex items-center gap-2">
            <input id="advPreferJunctions" type="checkbox" class="w-4 h-4" checked>
            <span>Privilégier les jonctions (deg ≥ 3)</span>
          </label>
        </div>
        <div class="border-t border-gray-200"></div>
        <div class="grid grid-cols-2 gap-3 text-sm">
          <label class="flex items-center gap-2">
            <input id="advEnableFilter" type="checkbox" class="w-4 h-4" checked>
            <span>Activer filtre utilité</span>
          </label>
          <label class="flex flex-col">
            <span>Coef. minimal (0–1)</span>
            <input id="advMinCoefficient" type="number" min="0" max="1" step="0.01" value="0.08" class="mt-1 px-2 py-1 border rounded-md"/>
          </label>
          <label class="flex flex-col">
            <span>Marge min (m)</span>
            <input id="advMinDistMargin" type="number" min="0" step="0.5" value="1.5" class="mt-1 px-2 py-1 border rounded-md"/>
          </label>
        </div>
        <p class="text-xs text-gray-500">Les paramètres sont pris en compte au prochain lancement d’analyse.</p>
      </div>

      <button id="startAnalysis"
              class="w-full py-2.5 px-4 bg-gradient-to-r from-rose-500 to-orange-500 text-white font-semibold rounded-xl shadow hover:shadow-md transition">
        Analyser les gaps
      </button>
      <div id="analysisStatus" class="text-xs text-gray-600">En attente…</div>
      <div class="progress-bar"><div id="analysisProgress" style="width:0%"></div></div>
      <div class="flex gap-2">
        <button id="zoomGaps" class="flex-1 py-2 px-3 bg-blue-600 text-white rounded-lg text-sm disabled:opacity-50" disabled>Zoom sur gaps</button>
        <button id="clearGaps" class="flex-1 py-2 px-3 bg-gray-200 text-gray-800 rounded-lg text-sm">Effacer</button>
      </div>
      <div class="text-sm"><span class="font-semibold">Gaps trouvés:</span> <span id="gapCount">0</span></div>
    </div>
  </div>

  <!-- Liste dépliable des discontinuités -->
  <div id="gapListPanel" class="hidden absolute top-6 right-6 z-30 w-80">
    <div class="bg-white/95 backdrop-blur-xl rounded-2xl shadow-2xl border border-gray-200/50 overflow-hidden">
      <button id="gapListToggle" class="w-full px-4 py-3 flex items-center justify-between text-left">
        <div class="flex items-center gap-2">
          <span class="text-xl">📎</span>
          <span class="font-semibold text-gray-800">Discontinuités</span>
          <span class="text-xs text-gray-500">(classées par coefficient)</span>
        </div>
        <div class="flex items-center gap-2">
          <span id="gapListCount" class="text-sm bg-gray-100 px-2 py-0.5 rounded-full">0</span>
          <i id="gapListChevron" class="fa-solid fa-chevron-down text-gray-600 transition-transform"></i>
        </div>
      </button>
      <div id="gapListContent" class="hidden border-t border-gray-200 max-h-72 overflow-y-auto"></div>
    </div>
  </div>

  <!-- Modal Dictionnaire des macros -->
  <div id="macroDocsModal" class="modal-overlay hidden">
    <div class="bg-white rounded-2xl shadow-2xl max-w-4xl w-[92%] p-6 md:p-8 overflow-y-auto max-h-[85vh]">
      <div class="flex items-center justify-between mb-4">
        <div class="flex items-center gap-3">
          <i class="fa-solid fa-book-open text-indigo-600 text-2xl"></i>
          <h2 class="text-xl md:text-2xl font-bold text-gray-800">Dictionnaire des macros</h2>
        </div>
        <button id="closeMacroDocs" class="p-2 rounded-lg hover:bg-gray-100">
          <i class="fa-solid fa-xmark text-gray-600 text-xl"></i>
        </button>
      </div>
      <p class="text-gray-600 mb-4">Utilisez ces libellés dans vos requêtes (ex: “transport:bus and eau in Marseille”). Chaque macro se déplie en tags OSM.</p>
      <div id="macroDocsContent" class="space-y-6"></div>
    </div>
  </div>

  <!-- Loading -->
  <div id="loadingOverlay" class="loading-overlay hidden">
    <div class="bg-white/90 backdrop-blur-xl rounded-3xl p-8 shadow-3xl text-center space-y-4 border-2 border-indigo-200">
      <div class="spinner"></div>
      <p class="text-xl font-semibold text-gray-700">Récupération des données OpenStreetMap...</p>
      <p class="text-sm text-gray-500" id="downloadStatus">Téléchargement…</p>
    </div>
  </div>

  <!-- Scripts -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.min.js"></script>

  <script>
    // Normalisation
    function normalize(str) {
      return (str || '')
        .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
        .toLowerCase();
    }

    // Aliases vers macros et sous-macros
    const macroAliases = {
      // Macros principales
      eau: 'macro_eau', water: 'macro_eau', reseaux_eau: 'macro_eau',
      transport: 'macro_transport', reseaux_transports: 'macro_transport',
      zone_residentielle: 'macro_residentiel', residentiel: 'macro_residentiel', residential: 'macro_residentiel',
      zone_commerciale: 'macro_commercial', commercial: 'macro_commercial', retail: 'macro_commercial',
      industriel: 'macro_industriel', industrie: 'macro_industriel', industrial: 'macro_industriel',
      vegetation: 'macro_vegetation', vegetal: 'macro_vegetation', green: 'macro_vegetation', espaces_verts: 'macro_vegetation',
      mobilites_douces: 'macro_mobilites', mobilites: 'macro_mobilites', modes_doux: 'macro_mobilites', soft_mobility: 'macro_mobilites', active_mobility: 'macro_mobilites',
      // Sous-macros transport (tokens sans préfixe transport:)
      bus: 'macro_transport:bus',
      tram: 'macro_transport:tram',
      subway: 'macro_transport:subway', metro: 'macro_transport:subway',
      rail: 'macro_transport:rail', train: 'macro_transport:rail',
      aerial: 'macro_transport:aerial', cable: 'macro_transport:aerial'
    };

    function preprocessTopics(text) {
      let s = normalize(text);
      s = s.replace(/\s+(?:and|et)\s+/g, ','); // séparateur unique ,
      // FR groupés
      s = s.replace(/\breseaux?\s+d'?eaux?\b/g, 'reseaux_eau');
      s = s.replace(/\breseaux?\s+de\s+transports?\b/g, 'reseaux_transports');
      s = s.replace(/\b(voies?|bandes?|couloirs?)\s+(de\s+)?bus\b/g, 'bus_lanes');
      s = s.replace(/\bpistes?\s+cyclables?\b/g, 'cycleway');
      s = s.replace(/\bzone\s+residentielles?\b/g, 'zone_residentielle');
      s = s.replace(/\bzone\s+commerciales?\b/g, 'zone_commerciale');
      s = s.replace(/\bespaces?\s+verts?\b/g, 'espaces_verts');
      s = s.replace(/\bmobilites?\s+douces?\b/g, 'mobilites_douces');
      // EN -> FR
      s = s.replace(/\bwater\s+networks?\b/g, 'reseaux_eau');
      s = s.replace(/\btransport\s+networks?\b/g, 'reseaux_transports');
      s = s.replace(/\bbus\s+lanes?\b/g, 'bus_lanes');
      s = s.replace(/\bcommercial\s+zone\b/g, 'zone_commerciale');
      s = s.replace(/\bresidential\s+zone\b/g, 'zone_residentielle');
      return s;
    }

    // Sujet atomiques → définitions
    const topics = {
      // Points
      stop: [{ type: 'node', filter: '["highway"="bus_stop"]' }], // On garde 'stop' pour arrêts
      school:     [{ type: 'node', filter: '["amenity"="school"]' }],
      university: [{ type: 'node', filter: '["amenity"="university"]' }],
      college:    [{ type: 'node', filter: '["amenity"="college"]' }],
      restaurant: [{ type: 'node', filter: '["amenity"="restaurant"]' }],
      cafe:       [{ type: 'node', filter: '["amenity"="cafe"]' }],
      bar:        [{ type: 'node', filter: '["amenity"="bar"]' }],
      hospital:   [{ type: 'node', filter: '["amenity"="hospital"]' }],
      clinic:     [{ type: 'node', filter: '["amenity"="clinic"]' }],
      shop:       [{ type: 'node', filter: '[shop]' }, { type:'way', filter:'[shop]' }],
      atm:        [{ type: 'node', filter: '["amenity"="atm"]' }],
      bank:       [{ type: 'node', filter: '["amenity"="bank"]' }],
      hotel:      [{ type: 'node', filter: '["tourism"="hotel"]' }],
      fountain:   [{ type: 'node', filter: '["amenity"="fountain"]' }, { type:'way', filter:'["amenity"="fountain"]' }],
      swimming_pool: [
        { type:'node', filter:'["leisure"="swimming_pool"]' },
        { type:'way', filter:'["leisure"="swimming_pool"]' },
        { type:'relation', filter:'["leisure"="swimming_pool"]' },
      ],
      park: [
        { type:'way', filter:'["leisure"="park"]' },
        { type:'relation', filter:'["leisure"="park"]' }
      ],
      // Cycleways
      cycleway: [
        { type: 'way', filter: '["highway"="cycleway"]' },
        { type: 'way', filter: '[~"^cycleway"~"."]' },
        { type: 'way', filter: '["bicycle_road"="yes"]' },
        { type: 'way', filter: '["highway"="path"]["bicycle"~"^(designated|official)$"]' },
        { type: 'way', filter: '["highway"="footway"]["bicycle"~"^(designated|official)$"]' },
        { type: 'way', filter: '["highway"~"^(trunk|primary|secondary|tertiary|residential|unclassified|service|living_street|primary_link|secondary_link|tertiary_link)$"][~"^cycleway"~"."]' },
        { type: 'way', filter: '["highway"~"^(trunk|primary|secondary|tertiary|residential|unclassified|service|living_street|primary_link|secondary_link|tertiary_link)$"]["bicycle"~"^(designated|official)$"]' }
      ],
      footway:    [{ type: 'way', filter:'["highway"="footway"]' }],
      sidewalk:   [{ type: 'way', filter:'["highway"="footway"]["footway"="sidewalk"]' }],
      path:       [{ type: 'way', filter:'["highway"="path"]' }],
      pedestrian: [{ type: 'way', filter:'["highway"="pedestrian"]' }],
      // Bus lanes dédiées (lignes)
      bus_lanes: [
        { type: 'way', filter: '["highway"="busway"]' },
        { type: 'way', filter: '[~"^busway(:|$)"~"."]' },
        { type: 'way', filter: '[~"^bus:lanes"~"."]' },
        { type: 'way', filter: '["psv"="designated"]' },
        { type: 'way', filter: '["bus"="designated"]' },
        { type: 'way', filter: '["access"="no"]["bus"="yes"]' }
      ],
      // Eau atomique
      river:  [{ type:'way', filter:'["waterway"="river"]' }],
      stream: [{ type:'way', filter:'["waterway"="stream"]' }],
      canal:  [{ type:'way', filter:'["waterway"="canal"]' }],
      drain:  [{ type:'way', filter:'["waterway"="drain"]' }],
      ditch:  [{ type:'way', filter:'["waterway"="ditch"]' }],
      wetlands:[{ type:'way', filter:'["natural"="wetland"]' }, { type:'relation', filter:'["natural"="wetland"]' }],
      lake: [
        { type:'way', filter:'["natural"="water"]["water"="lake"]' },
        { type:'relation', filter:'["natural"="water"]["water"="lake"]' }
      ],
      pond: [
        { type:'way', filter:'["natural"="water"]["water"="pond"]' },
        { type:'relation', filter:'["natural"="water"]["water"="pond"]' }
      ],
      reservoir: [
        { type:'way', filter:'["natural"="water"]["water"="reservoir"]' },
        { type:'relation', filter:'["natural"="water"]["water"="reservoir"]' },
        { type:'way', filter:'["landuse"="reservoir"]' },
        { type:'relation', filter:'["landuse"="reservoir"]' }
      ],
      basin: [
        { type:'way', filter:'["natural"="water"]["water"="basin"]' },
        { type:'relation', filter:'["natural"="water"]["water"="basin"]' },
        { type:'way', filter:'["landuse"="basin"]' },
        { type:'relation', filter:'["landuse"="basin"]' }
      ]
    };

    // Macros + sous-macros
    const macros = {
      macro_eau: {
        title: 'Eau',
        selectors: [
          { types:['way'], filter:'["waterway"~"^(river|stream|canal|drain|ditch|wadi)$"]' },
          { types:['way'], filter:'["waterway"="riverbank"]' },
          { types:['relation'], filter:'["waterway"="riverbank"]' },
          { types:['way'], filter:'["natural"="water"]' },
          { types:['relation'], filter:'["natural"="water"]' },
          { types:['way'], filter:'["natural"="wetland"]' },
          { types:['relation'], filter:'["natural"="wetland"]' },
          { types:['way'], filter:'["landuse"~"^(reservoir|basin)$"]' },
          { types:['relation'], filter:'["landuse"~"^(reservoir|basin)$"]' },
          { types:['way'], filter:'["natural"="water"]["water"~"^(lake|pond|reservoir|basin|lagoon|oxbow|canal|river|stream|wastewater)$"]' },
          { types:['relation'], filter:'["natural"="water"]["water"~"^(lake|pond|reservoir|basin|lagoon|oxbow|canal|river|stream|wastewater)$"]' },
          { types:['node'], filter:'["natural"="spring"]' },
          { types:['node','way'], filter:'["man_made"~"^(dam|pumping_station|reservoir_covered|water_tower|wastewater_plant|water_well)$"]' },
          { types:['node','way','relation'], filter:'["amenity"="fountain"]' },
          { types:['node','way','relation'], filter:'["leisure"="swimming_pool"]' },
          { types:['way'], filter:'["natural"="coastline"]' }
        ],
        doc: [
          'natural=water|wetland',
          'waterway=river|stream|canal|drain|ditch|riverbank',
          'landuse=reservoir|basin',
          'amenity=fountain, leisure=swimming_pool',
          'man_made=dam|water_tower|pumping_station|wastewater_plant'
        ]
      },
      macro_transport: {
        title:'Transport',
        selectors:[ // macro générale
          { types:['way'], filter:'["railway"~"^(rail|tram|light_rail|subway|narrow_gauge)$"]' },
          { types:['way'], filter:'[~"^aerialway"~"."]' },
          { types:['way'], filter:'["highway"="busway"]' },
          { types:['way'], filter:'[~"^busway(:|$)"~"."]' },
          { types:['way'], filter:'[~"^bus:lanes"~"."]' }
        ],
        subs: {
          bus: {
            title: 'Transport — Bus (lignes)',
            selectors: [
              { types:['relation'], filter:'["type"="route"]["route"="bus"]' }, // lignes
              { types:['way'], filter:'["highway"="busway"]' },
              { types:['way'], filter:'[~"^busway(:|$)"~"."]' },
              { types:['way'], filter:'[~"^bus:lanes"~"."]' },
              { types:['way'], filter:'["psv"="designated"]' },
              { types:['way'], filter:'["bus"="designated"]' },
              { types:['way'], filter:'["access"="no"]["bus"="yes"]' }
            ],
            doc: [
              'relations type=route, route=bus',
              'highway=busway, busway:*, bus:lanes=*, psv=designated'
            ]
          },
          tram: {
            title: 'Transport — Tram',
            selectors: [
              { types:['way'], filter:'["railway"="tram"]' },
              { types:['relation'], filter:'["type"="route"]["route"="tram"]' }
            ],
            doc: ['railway=tram', 'relations route=tram']
          },
          subway: {
            title: 'Transport — Métro',
            selectors: [
              { types:['way'], filter:'["railway"="subway"]' },
              { types:['relation'], filter:'["type"="route"]["route"="subway"]' }
            ],
            doc: ['railway=subway', 'relations route=subway']
          },
          rail: {
            title: 'Transport — Rail',
            selectors: [
              { types:['way'], filter:'["railway"~"^(rail|light_rail|narrow_gauge)$"]' },
              { types:['relation'], filter:'["type"="route"]["route"~"^(train|rail|light_rail)$"]' }
            ],
            doc: ['railway=rail|light_rail|narrow_gauge', 'relations route=train|rail|light_rail']
          },
          aerial: {
            title: 'Transport — Aérien',
            selectors: [
              { types:['way'], filter:'[~"^aerialway"~"."]' },
              { types:['relation'], filter:'["type"="route"]["route"~"^(cable_car|gondola|chair_lift)$"]' }
            ],
            doc: ['aerialway=*', 'relations route=cable_car|gondola|chair_lift']
          },
          stops: {
            title: 'Transport — Arrêts',
            selectors: [
              { types:['node'], filter:'["highway"="bus_stop"]' },
              { types:['node','way','relation'], filter:'["public_transport"~"^(platform|stop_position)$"]' }
            ],
            doc: ['highway=bus_stop', 'public_transport=platform|stop_position']
          }
        },
        doc:[
          'railway=rail|tram|light_rail|subway…',
          'aerialway=*',
          'highway=busway, busway:*, bus:lanes=*',
          'Sous-macros: bus | tram | subway | rail | aerial | stops'
        ]
      },
      macro_residentiel: {
        title:'Résidentiel',
        selectors:[
          { types:['way','relation'], filter:'["landuse"="residential"]' },
          { types:['way'], filter:'["highway"~"^(residential|living_street)$"]' },
          { types:['way','relation'], filter:'["building"~"^(residential|apartments|house|detached|terrace|semidetached_house|dormitory)$"]' }
        ],
        doc:[
          'landuse=residential',
          'highway=residential|living_street',
          'building=residential|apartments|house|detached|terrace|semidetached_house'
        ]
      },
      macro_commercial: {
        title:'Commercial',
        selectors:[
          { types:['way','relation'], filter:'["landuse"~"^(commercial|retail)$"]' },
          { types:['node','way'], filter:'[shop]' },
          { types:['node','way'], filter:'["amenity"="marketplace"]' },
          { types:['node','way'], filter:'["amenity"~"^(restaurant|fast_food|cafe|bar|pub|biergarten|food_court)$"]' },
          { types:['node','way'], filter:'["amenity"~"^(bank|atm|bureau_de_change)$"]' },
          { types:['node','way'], filter:'["amenity"~"^(fuel|car_wash|car_rental|car_sharing)$"]' },
          { types:['way','relation'], filter:'["building"~"^(commercial|retail|supermarket|warehouse|mall)$"]' },
          { types:['node','way'], filter:'[office]' }
        ],
        doc:[
          'landuse=commercial|retail, shop=*',
          'amenity=marketplace|restaurant|fast_food|cafe|bar|pub|bank|atm|fuel…',
          'building=commercial|retail|supermarket|mall, office=*'
        ]
      },
      macro_industriel: {
        title:'Industriel',
        selectors:[
          { types:['way','relation'], filter:'["landuse"="industrial"]' },
          { types:['node','way'], filter:'["man_made"="works"]' },
          { types:['node','way'], filter:'[industrial]' },
          { types:['way','relation'], filter:'["building"~"^(industrial|manufacture|warehouse|hangar|factory)$"]' },
          { types:['node','way'], filter:'["power"="plant"]' }
        ],
        doc:[
          'landuse=industrial',
          'man_made=works, industrial=*',
          'building=industrial|warehouse|factory, power=plant'
        ]
      },
      macro_vegetation: {
        title:'Végétation',
        selectors:[
          { types:['way','relation'], filter:'["landuse"~"^(forest|meadow|grass|orchard|vineyard|allotments)$"]' },
          { types:['way','relation'], filter:'["natural"~"^(wood|scrub|heath|grassland)$"]' },
          { types:['way','relation'], filter:'["leisure"~"^(park|garden)$"]' }
        ],
        doc:[
          'landuse=forest|meadow|grass|orchard|vineyard|allotments',
          'natural=wood|scrub|heath|grassland',
          'leisure=park|garden'
        ]
      },
      macro_mobilites: {
        title:'Mobilités douces (piétons)',
        selectors:[
          { types:['way'], filter:'["highway"="footway"]' },
          { types:['way'], filter:'["highway"="footway"]["footway"="sidewalk"]' },
          { types:['way'], filter:'["highway"="path"]["foot"~"^(designated|yes)$"]' },
          { types:['way'], filter:'["highway"="pedestrian"]' },
          { types:['way'], filter:'["footway"="crossing"]' }, // lignes de traversée piéton
          { types:['node'], filter:'["highway"="crossing"]' }, // passages piétons (noeuds)
          { types:['way'], filter:'["highway"="steps"]' }      // escaliers (optionnel)
        ],
        doc:[
          'highway=footway|pedestrian|steps, footway=sidewalk|crossing',
          'highway=crossing (noeuds), path[foot=designated|yes]'
        ]
      }
    };

    // Résolution macros + sous-macros -> filtres Overpass
    function resolveWordsToFilters(words) {
      const nodeFilters = new Set();
      const wayFilters = new Set();
      const relFilters = new Set();

      function addSelector(sel) {
        const types = Array.isArray(sel.types) ? sel.types : ['node','way','relation'];
        if (types.includes('node')) nodeFilters.add(sel.filter);
        if (types.includes('way')) wayFilters.add(sel.filter);
        if (types.includes('relation')) relFilters.add(sel.filter);
      }

      function expandMacroKey(mKey) {
        const def = macros[mKey];
        if (!def) return;
        (def.selectors || []).forEach(addSelector);
      }

      function expandSubMacro(mKey, subKey) {
        const def = macros[mKey];
        if (!def) return false;
        if (def.subs && def.subs[subKey]) {
          (def.subs[subKey].selectors || []).forEach(addSelector);
          return true;
        }
        return false;
      }

      for (const raw of words) {
        let w = raw;

        // Notation sous-macro: ex "transport:bus"
        if (w.includes(':')) {
          const [base, sub] = w.split(':', 2);
          const alias = macroAliases[base] || base;
          const mKey = macroAliases[alias] || alias; // normaliser vers macro_*
          // si alias retourne déjà 'macro_...'
          const macroKey = mKey.startsWith('macro_') ? mKey : macroAliases[mKey] || mKey;
          if (macroKey.startsWith('macro_')) {
            // Sous-macro via alias directe (ex: "bus" → macro_transport:bus)
            const aliasFull = macroAliases[w];
            if (aliasFull && aliasFull.includes(':')) {
              const [ak, asub] = aliasFull.split(':', 2);
              if (!expandSubMacro(ak, asub)) expandMacroKey(ak);
              continue;
            }
            // Sinon base:sub
            if (!expandSubMacro(macroKey, sub)) {
              // fallback macro base si sous-macro inconnue
              expandMacroKey(macroKey);
            }
            continue;
          }
        }

        // Alias directs vers sous-macro (ex "bus" → macro_transport:bus)
        const aliasFull = macroAliases[w];
        if (aliasFull && aliasFull.includes(':')) {
          const [mk, subk] = aliasFull.split(':', 2);
          if (!expandSubMacro(mk, subk)) expandMacroKey(mk);
          continue;
        }

        // Alias vers macro (ex "eau" → macro_eau)
        const aliasMacro = macroAliases[w];
        if (aliasMacro && aliasMacro.startsWith('macro_')) {
          expandMacroKey(aliasMacro);
          continue;
        }

        // Sujets atomiques connus
        const defs = topics[w];
        if (defs) {
          defs.forEach(d => {
            if (d.type === 'node') nodeFilters.add(d.filter);
            else if (d.type === 'way') wayFilters.add(d.filter);
            else if (d.type === 'relation') relFilters.add(d.filter);
          });
        }
      }

      return {
        nodeFilters: Array.from(nodeFilters),
        wayFilters: Array.from(wayFilters),
        relFilters: Array.from(relFilters)
      };
    }

    // Carte
    const map = L.map('map').setView([48.8566, 2.3522], 12);
    L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; OpenStreetMap &copy; CARTO'
    }).addTo(map);

    // État
    let featureLayers = [];
    let gapMarkers = [];
    let suggestionLines = [];
    let lastFetchedElements = [];
    let gapItems = [];

    // DOM
    const searchInput = document.getElementById('searchInput');
    const searchButton = document.getElementById('searchButton');
    const errorDisplay = document.getElementById('errorDisplay');
    const errorMessage = document.getElementById('errorMessage');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const downloadStatus = document.getElementById('downloadStatus');
    const resultsCounter = document.getElementById('resultsCounter');
    const resultCount = document.getElementById('resultCount');
    const fitButton = document.getElementById('fitButton');
    const searchPanel = document.querySelector('.search-panel');
    const newSearchButton = document.getElementById('newSearchButton');

    const analysisPanel = document.getElementById('analysisPanel');
    const startAnalysis = document.getElementById('startAnalysis');
    const analysisProgress = document.getElementById('analysisProgress');
    const analysisStatus = document.getElementById('analysisStatus');
    const gapCount = document.getElementById('gapCount');
    const zoomGaps = document.getElementById('zoomGaps');
    const clearGapsBtn = document.getElementById('clearGaps');
    const includeBusLanes = document.getElementById('includeBusLanes');
    const joinThresholdInput = document.getElementById('joinThreshold');
    const gapRadiusInput = document.getElementById('gapRadius');
    const sampleResolutionInput = document.getElementById('sampleResolution');

    // Avancés
    const advancedSettingsToggle = document.getElementById('advancedSettingsToggle');
    const advancedPanel = document.getElementById('advancedPanel');
    const advCandidateSpacing = document.getElementById('advCandidateSpacing');
    const advMaxInternalPerComp = document.getElementById('advMaxInternalPerComp');
    const advCapEndpoints = document.getElementById('advCapEndpoints');
    const advPreferJunctions = document.getElementById('advPreferJunctions');
    const advEnableFilter = document.getElementById('advEnableFilter');
    const advMinCoefficient = document.getElementById('advMinCoefficient');
    const advMinDistMargin = document.getElementById('advMinDistMargin');

    const gapListPanel = document.getElementById('gapListPanel');
    const gapListToggle = document.getElementById('gapListToggle');
    const gapListContent = document.getElementById('gapListContent');
    const gapListChevron = document.getElementById('gapListChevron');
    const gapListCount = document.getElementById('gapListCount');

    // Docs macros
    const openMacroDocs = document.getElementById('openMacroDocs');
    const macroDocsModal = document.getElementById('macroDocsModal');
    const closeMacroDocs = document.getElementById('closeMacroDocs');
    const macroDocsContent = document.getElementById('macroDocsContent');

    // Icônes points
    function getIconForFeature(tags) {
      if (tags.highway === 'bus_stop') return L.AwesomeMarkers.icon({ icon: 'bus', prefix: 'fa', markerColor: 'blue' });
      if (['school','college','university'].includes(tags.amenity)) return L.AwesomeMarkers.icon({ icon: 'school', prefix: 'fa', markerColor: 'green' });
      if (tags.amenity === 'restaurant') return L.AwesomeMarkers.icon({ icon: 'utensils', prefix: 'fa', markerColor: 'orange' });
      if (tags.amenity === 'cafe') return L.AwesomeMarkers.icon({ icon: 'coffee', prefix: 'fa', markerColor: 'cadetblue' });
      if (tags.amenity === 'bar') return L.AwesomeMarkers.icon({ icon: 'martini-glass', prefix: 'fa', markerColor: 'darkred' });
      if (tags.amenity === 'hospital' || tags.amenity === 'clinic') return L.AwesomeMarkers.icon({ icon: 'kit-medical', prefix: 'fa', markerColor: 'red' });
      if (tags.shop) return L.AwesomeMarkers.icon({ icon: 'store', prefix: 'fa', markerColor: 'purple' });
      if (tags.amenity === 'bank') return L.AwesomeMarkers.icon({ icon: 'building-columns', prefix: 'fa', markerColor: 'blue' });
      if (tags.amenity === 'atm') return L.AwesomeMarkers.icon({ icon: 'money-bill-wave', prefix: 'fa', markerColor: 'darkgreen' });
      if (tags.tourism === 'hotel') return L.AwesomeMarkers.icon({ icon: 'bed', prefix: 'fa', markerColor: 'cadetblue' });
      if (tags.leisure === 'park') return L.AwesomeMarkers.icon({ icon: 'tree', prefix: 'fa', markerColor: 'darkgreen' });
      if (tags.natural === 'spring') return L.AwesomeMarkers.icon({ icon: 'tint', prefix: 'fa', markerColor: 'darkblue' });
      if (tags.amenity === 'fountain') return L.AwesomeMarkers.icon({ icon: 'faucet', prefix: 'fa', markerColor: 'blue' });
      return L.AwesomeMarkers.icon({ icon: 'info-circle', prefix: 'fa', markerColor: 'gray' });
    }

    // Helpers cyclables
    const ROAD_HIGHWAYS = new Set(['trunk','primary','secondary','tertiary','residential','unclassified','service','living_street','primary_link','secondary_link','tertiary_link']);
    function hasCyclewayKey(tags) {
      return Object.keys(tags).some(k => /^cycleway/.test(k)) || typeof tags.cycleway !== 'undefined';
    }
    function isRoadHighway(h) { return ROAD_HIGHWAYS.has(h); }
    function isCycleLike(tags) {
      return tags.highway === 'cycleway'
        || hasCyclewayKey(tags)
        || tags.bicycle_road === 'yes'
        || (tags.highway === 'path' && /^(designated|official)$/.test(tags.bicycle||''))
        || (tags.highway === 'footway' && /^(designated|official)$/.test(tags.bicycle||''))
        || (isRoadHighway(tags.highway || '') && (hasCyclewayKey(tags) || /^(designated|official|yes)$/.test(tags.bicycle||'')));
    }
    function isBusLaneLike(tags) {
      return tags.highway === 'busway' || 'busway' in tags || Object.keys(tags).some(k => k.startsWith('bus:lanes')) || tags.bus === 'designated' || tags.psv === 'designated';
    }

    // Styles lignes/polygones (réseau cyclable en VERT)
    function getStyleForFeature(tags) {
      if (isCycleLike(tags)) return { color: '#16a34a', weight: 3, opacity: 0.95 };
      if (tags.highway === 'footway')  return { color: '#8b5e3c', weight: 3, opacity: 0.9, dashArray: '6,4' };
      if (tags.highway === 'path')     return { color: '#7c3aed', weight: 3, opacity: 0.9, dashArray: '8,4' };
      if (tags.highway === 'pedestrian') return { color: '#15803d', weight: 3, opacity: 0.9, dashArray: '4,2' };
      if (tags.highway === 'busway' || 'busway' in tags || Object.keys(tags).some(k => k.startsWith('bus:lanes'))) return { color: '#f59e0b', weight: 4, opacity: 0.95 };
      if (tags.railway)   return { color: '#6b7280', weight: 3, opacity: 0.9, dashArray: '6,3' };
      if (tags.aerialway) return { color: '#fb7185', weight: 3, opacity: 0.9, dashArray: '4,4' };
      if (tags.waterway === 'river')   return { color: '#1d4ed8', weight: 4, opacity: 0.9 };
      if (tags.waterway === 'canal')   return { color: '#0ea5e9', weight: 4, opacity: 0.9 };
      if (tags.waterway === 'stream')  return { color: '#60a5fa', weight: 3, opacity: 0.9 };
      if (tags.waterway === 'drain')   return { color: '#38bdf8', weight: 2.5, opacity: 0.9, dashArray: '4,3' };
      if (tags.waterway === 'ditch')   return { color: '#93c5fd', weight: 2.5, opacity: 0.9, dashArray: '4,3' };
      if (['weir','lock_gate','sluice_gate'].includes(tags.waterway)) return { color: '#22d3ee', weight: 2.5, opacity: 0.9, dashArray: '2,4' };
      if (tags.natural === 'water' || tags.water || tags.landuse === 'reservoir' || tags.natural === 'wetland' || tags.waterway === 'riverbank') {
        return { color: '#38bdf8', weight: 2, opacity: 0.8, fill: true, fillColor: '#93c5fd', fillOpacity: 0.35 };
      }
      if (['industrial','commercial','retail'].includes(tags.landuse)) {
        return { color: '#f97316', weight: 2, fill: true, fillColor: '#fdba74', fillOpacity: 0.25 };
      }
      if (tags.landuse === 'residential') {
        return { color: '#22c55e', weight: 2, fill: true, fillColor: '#86efac', fillOpacity: 0.25 };
      }
      return { color: '#555', weight: 2, opacity: 0.8 };
    }

    // Parsing "topics in city" + macros
    function parseQuery(q) {
      const lower = q.toLowerCase().trim();
      const m = lower.match(/(.+?)\s+in\s+(.+)$/i);
      if (!m) throw new Error('Format attendu: "sujets in ville" (ex: transport:bus et mobilites_douces in Toulouse)');
      const topicRaw = m[1];
      const city = m[2].trim();
      if (!city) throw new Error('La ville est requise.');

      const normalized = preprocessTopics(topicRaw);
      const words = normalized.split(/[,\s;+/]+/).map(w => w.trim()).filter(Boolean);

      const { nodeFilters, wayFilters, relFilters } = resolveWordsToFilters(words);

      if (nodeFilters.length === 0 && wayFilters.length === 0 && relFilters.length === 0) {
        throw new Error(`Aucun sujet/macro reconnu dans "${topicRaw}". Consultez le dictionnaire des macros.`);
      }
      return { nodeFilters, wayFilters, relFilters, city };
    }

    function clearLayers() {
      featureLayers.forEach(l => map.removeLayer(l));
      featureLayers = [];
      gapMarkers.forEach(m => map.removeLayer(m));
      gapMarkers = [];
      suggestionLines.forEach(l => map.removeLayer(l));
      suggestionLines = [];
      lastFetchedElements = [];
      gapItems = [];
      gapCount.textContent = '0';
      zoomGaps.disabled = true;
      setAnalysisProgress(0, 'En attente…');
      gapListPanel.classList.add('hidden');
      gapListContent.classList.add('hidden');
      gapListChevron.classList.remove('rotate-180');
      gapListCount.textContent = '0';
      gapListContent.innerHTML = '';
    }

    function isClosedPolygon(geom) {
      if (!geom || geom.length < 4) return false;
      const a = geom[0], b = geom[geom.length - 1];
      return Math.abs(a.lat - b.lat) < 1e-9 && Math.abs(a.lon - b.lon) < 1e-9;
    }

    // Overpass par lots avec recursion >> (pour relations route=*)
    async function fetchOverpassBatches(bbox, nodeFilters, wayFilters, relFilters, onBatchProgress) {
      const statements = [];
      nodeFilters.forEach(f => statements.push(`node${f}(${bbox});`));
      wayFilters.forEach(f => statements.push(`way${f}(${bbox});`));
      relFilters.forEach(f => statements.push(`relation${f}(${bbox});`));

      const maxPerBatch = 16;
      const batches = [];
      for (let i = 0; i < statements.length; i += maxPerBatch) {
        batches.push(statements.slice(i, i + maxPerBatch));
      }

      const elementsMap = new Map();
      for (let i = 0; i < batches.length; i++) {
        const parts = batches[i].join('\n  ');
        const query = `[out:json][timeout:180];
(
  ${parts}
)->.s;
(.s; >>;);
out geom;`;
        const opUrl = 'https://overpass-api.de/api/interpreter';
        const res = await fetch(opUrl, { method: 'POST', body: `data=${encodeURIComponent(query)}` });
        if (!res.ok) {
          const body = await res.text();
          throw new Error(`Erreur API Overpass: ${res.status} ${res.statusText}. ${body.substring(0,200)}`);
        }
        const json = await res.json();
        (json.elements || []).forEach(el => {
          const key = `${el.type}:${el.id}`;
          if (!elementsMap.has(key)) elementsMap.set(key, el);
        });
        if (onBatchProgress) onBatchProgress(i + 1, batches.length);
        await new Promise(r => setTimeout(r, 60)); // petite pause
      }
      return Array.from(elementsMap.values());
    }

    async function handleSearch() {
      errorDisplay.classList.add('hidden');
      clearLayers();
      loadingOverlay.classList.remove('hidden');
      resultsCounter.classList.add('hidden');
      analysisPanel.classList.add('hidden');
      downloadStatus.textContent = 'Téléchargement…';

      try {
        const { nodeFilters, wayFilters, relFilters, city } = parseQuery(searchInput.value);

        // Géocodage
        const nomUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(city)}&limit=1&addressdetails=1`;
        const nomRes = await fetch(nomUrl);
        if (!nomRes.ok) throw new Error('Échec du géocodage');
        const nomData = await nomRes.json();
        if (nomData.length === 0) throw new Error(`Aucun lieu trouvé pour '${city}'.`);

        const place = nomData[0];
        const [south, north, west, east] = place.boundingbox.map(parseFloat);
        const bbox = `${south},${west},${north},${east}`;
        map.fitBounds([[south, west], [north, east]]);

        // Téléchargement par lots
        const elements = await fetchOverpassBatches(bbox, nodeFilters, wayFilters, relFilters, (done, total) => {
          downloadStatus.textContent = `Téléchargement ${done}/${total}…`;
        });

        // Affichage
        elements.forEach(el => {
          const tags = el.tags || {};
          const name = tags.name || 'Élément sans nom';
          let layer;
          let popup = `<div style="font-family: system-ui, sans-serif; line-height:1.4;">
            <h3 style="font-size:16px;font-weight:700;margin-bottom:8px;">${name}</h3>
            <div style="font-size:13px;max-height:150px;overflow-y:auto;">`;
          Object.entries(tags).forEach(([k, v]) => { popup += `<div><strong>${k}:</strong> ${v}</div>`; });
          popup += `</div></div>`;

          if (el.type === 'node' && el.lat && el.lon) {
            layer = L.marker([el.lat, el.lon], { icon: getIconForFeature(tags) }).addTo(map);
          } else if ((el.type === 'way' || el.type === 'relation') && el.geometry && el.geometry.length > 1) {
            const latLngs = el.geometry.map(pt => [pt.lat, pt.lon]);
            if (isClosedPolygon(el.geometry) && (tags.natural === 'water' || tags.landuse === 'reservoir' || tags.natural === 'wetland' || tags.leisure === 'park' || tags.waterway === 'riverbank' || tags.landuse === 'residential' || ['industrial','commercial','retail'].includes(tags.landuse))) {
              layer = L.polygon(latLngs, { ...getStyleForFeature(tags) }).addTo(map);
            } else {
              layer = L.polyline(latLngs, getStyleForFeature(tags)).addTo(map);
            }
          }
          if (layer) {
            layer.bindPopup(popup, { maxWidth: 320 });
            featureLayers.push(layer);
          }
        });

        lastFetchedElements = elements;
        if (featureLayers.length > 0) {
          resultCount.textContent = featureLayers.length;
          resultsCounter.classList.remove('hidden');
        }

        searchPanel.classList.add('hidden');
        newSearchButton.classList.remove('hidden');
        analysisPanel.classList.remove('hidden');

      } catch (err) {
        errorMessage.textContent = err.message || 'Erreur inconnue.';
        errorDisplay.classList.remove('hidden');
      } finally {
        loadingOverlay.classList.add('hidden');
      }
    }

    // ==== Analyse Gaps (inchangée depuis la version précédente enrichie) ====

    function toRad(x) { return x * Math.PI / 180; }
    function haversine(a, b) {
      const R = 6371000;
      const dLat = toRad(b.lat - a.lat);
      const dLon = toRad(b.lon - a.lon);
      const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
      const s = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
      return 2 * R * Math.asin(Math.sqrt(s));
    }

    function setAnalysisProgress(pct, msg) {
      analysisProgress.style.width = `${Math.min(100, Math.max(0, pct))}%`;
      analysisStatus.textContent = msg;
    }

    function samplePointsOnSegment(start, end, resolutionMeters) {
      const total = haversine(start, end);
      if (!isFinite(total) || total <= 0) return [start, end];
      if (total <= resolutionMeters) return [start, end];
      const segments = Math.max(1, Math.round(total / resolutionMeters));
      const points = [];
      for (let k = 0; k <= segments; k++) {
        const t = k / segments;
        const lat = start.lat + t * (end.lat - start.lat);
        const lon = start.lon + t * (end.lon - start.lon);
        points.push({ lat, lon });
      }
      return points;
    }

    function buildGrid(points, dLat, dLon) {
      const grid = new Map();
      function keyFor(lat, lon) {
        const x = Math.floor(lon / dLon);
        const y = Math.floor(lat / dLat);
        return `${x},${y}`;
      }
      points.forEach((p, i) => {
        const key = keyFor(p.lat, p.lon);
        if (!grid.has(key)) grid.set(key, []);
        grid.get(key).push(i);
      });
      return { grid, keyFor };
    }

    function findComponentConnectionPoints(componentSet, graph, nodeCoord, options) {
      const {
        capEndpoints = 80,
        maxInternalPerComponent = 60,
        candidateSpacingMeters = 120,
        centerLat = 45,
        preferJunctions = true
      } = options || {};

      const degLat = candidateSpacingMeters / 111320;
      const degLon = candidateSpacingMeters / (111320 * Math.cos(centerLat * Math.PI / 180));
      const cellKey = (lat, lon) => `${Math.floor(lon / degLon)},${Math.floor(lat / degLat)}`;

      const endpoints = [];
      const cellBest = new Map();

      componentSet.forEach(id => {
        const deg = graph.get(id)?.size || 0;
        const c = nodeCoord.get(id);
        if (!c) return;
        if (deg === 1) {
          endpoints.push({ id, lat: c.lat, lon: c.lon, deg });
        } else if (deg >= 2) {
          const key = cellKey(c.lat, c.lon);
          const prev = cellBest.get(key);
          if (!prev) cellBest.set(key, { id, lat: c.lat, lon: c.lon, deg });
          else if (preferJunctions && prev.deg < 3 && deg >= 3) cellBest.set(key, { id, lat: c.lat, lon: c.lon, deg });
        }
      });

      let endpointsReduced = endpoints;
      if (endpoints.length > capEndpoints) {
        const step = Math.ceil(endpoints.length / capEndpoints);
        endpointsReduced = [];
        for (let i = 0; i < endpoints.length; i += step) endpointsReduced.push(endpoints[i]);
      }

      let internal = Array.from(cellBest.values());
      if (internal.length > maxInternalPerComponent) {
        const step = Math.ceil(internal.length / maxInternalPerComponent);
        const reduced = [];
        for (let i = 0; i < internal.length; i += step) reduced.push(internal[i]);
        internal = reduced;
      }

      const outMap = new Map();
      [...endpointsReduced, ...internal].forEach(p => outMap.set(p.id, { id: p.id, lat: p.lat, lon: p.lon }));
      return Array.from(outMap.values());
    }

    function greedyNearestUniquePairs(A, B, joinThreshold, gapRadius, dLat, dLon, maxPairs = 2) {
      if (A.length === 0 || B.length === 0) return [];
      const { grid } = buildGrid(B, dLat, dLon);
      const candidates = [];

      for (let ai = 0; ai < A.length; ai++) {
        const a = A[ai];
        const cx = Math.floor(a.lon / dLon);
        const cy = Math.floor(a.lat / dLat);
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            const arr = grid.get(`${cx + dx},${cy + dy}`);
            if (!arr) continue;
            for (const bi of arr) {
              const b = B[bi];
              const d = haversine(a, b);
              if (d > joinThreshold && d <= gapRadius) {
                candidates.push({ ai, bi, d });
              }
            }
          }
        }
      }

      candidates.sort((x, y) => x.d - y.d);
      const usedA = new Set();
      const usedB = new Set();
      const pairs = [];
      for (const c of candidates) {
        if (pairs.length >= maxPairs) break;
        if (usedA.has(c.ai) || usedB.has(c.bi)) continue;
        usedA.add(c.ai);
        usedB.add(c.bi);
        pairs.push(c);
      }
      return pairs;
    }

    const GAP_STYLE_CONFIG = {
      colorStart: '#f59e0b',
      colorMid:   '#ef4444',
      colorEnd:   '#7f1d1d',
      gapLineWeight: 4,
      gapMarkerRadius: 6,
      gapMarkerBorderWeight: 2,
      gapMarkerFillOpacity: 0.95,
      dashArray: '6,6',
      lineOpacity: 0.95
    };

    const DEFAULT_GAP_FILTERS = {
      enableConnectivityFilter: true,
      minCoefficient: 0.08,
      minDistanceMarginMeters: 1.5
    };

    function hexToRgb(hex) {
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return m ? { r: parseInt(m[1], 16), g: parseInt(m[2], 16), b: parseInt(m[3], 16) } : { r:0,g:0,b:0 };
    }
    function rgbToHex(r,g,b) { const toHex = v => ('0' + v.toString(16)).slice(-2); return `#${toHex(r)}${toHex(g)}${toHex(b)}`; }
    function lerp(a, b, t) { return a + (b - a) * t; }
    function clamp01(x) { return Math.max(0, Math.min(1, x)); }

    function computeGapCoefficient(sizeA, sizeB, maxComponentSize, distance, joinThreshold, gapRadius) {
      const denom = Math.max(1, gapRadius - joinThreshold);
      const distScore = clamp01((distance - joinThreshold) / denom);
      let netScore = 0;
      if (maxComponentSize > 0) {
        const a = clamp01(sizeA / maxComponentSize);
        const b = clamp01(sizeB / maxComponentSize);
        netScore = Math.sqrt(a * b);
      }
      const coef = Math.sqrt(distScore * netScore);
      return clamp01(coef);
    }

    function getGapColorFromCoeff(coef) {
      const t = clamp01(coef);
      const c1 = hexToRgb(GAP_STYLE_CONFIG.colorStart);
      const c2 = hexToRgb(GAP_STYLE_CONFIG.colorMid);
      const c3 = hexToRgb(GAP_STYLE_CONFIG.colorEnd);
      if (t <= 0.5) {
        const tt = t / 0.5;
        const r = Math.round(lerp(c1.r, c2.r, tt));
        const g = Math.round(lerp(c1.g, c2.g, tt));
        const b = Math.round(lerp(c1.b, c2.b, tt));
        return rgbToHex(r,g,b);
      } else {
        const tt = (t - 0.5) / 0.5;
        const r = Math.round(lerp(c2.r, c3.r, tt));
        const g = Math.round(lerp(c2.g, c3.g, tt));
        const b = Math.round(lerp(c2.b, c3.b, tt));
        return rgbToHex(r,g,b);
      }
    }

    function getAdvancedSettings() {
      const enableConnectivityFilter = advEnableFilter?.checked ?? DEFAULT_GAP_FILTERS.enableConnectivityFilter;
      const minCoefficient = parseFloat(advMinCoefficient?.value);
      const minDistanceMarginMeters = parseFloat(advMinDistMargin?.value);
      const candidateSpacingMeters = parseFloat(advCandidateSpacing?.value);
      const maxInternalPerComponent = parseInt(advMaxInternalPerComp?.value, 10);
      const capEndpoints = parseInt(advCapEndpoints?.value, 10);
      const preferJunctions = !!advPreferJunctions?.checked;

      return {
        enableConnectivityFilter,
        minCoefficient: isFinite(minCoefficient) ? minCoefficient : DEFAULT_GAP_FILTERS.minCoefficient,
        minDistanceMarginMeters: isFinite(minDistanceMarginMeters) ? minDistanceMarginMeters : DEFAULT_GAP_FILTERS.minDistanceMarginMeters,
        candidateSpacingMeters: isFinite(candidateSpacingMeters) ? candidateSpacingMeters : 120,
        maxInternalPerComponent: Number.isInteger(maxInternalPerComponent) ? maxInternalPerComponent : 60,
        capEndpoints: Number.isInteger(capEndpoints) ? capEndpoints : 80,
        preferJunctions
      };
    }

    async function runNetworkGapsAnalysis() {
      if (!lastFetchedElements || lastFetchedElements.length === 0) {
        analysisStatus.textContent = "Aucun réseau chargé.";
        return;
      }

      const includeBus = includeBusLanes.checked;
      const joinThreshold = Math.max(1, Number(joinThresholdInput?.value) || 15);
      const gapRadius = Math.max(joinThreshold + 1, Number(gapRadiusInput?.value) || 120);
      const sampleResolution = Math.max(10, Math.min(200, Number(sampleResolutionInput?.value) || 50));
      const precision = 1e7;

      const adv = getAdvancedSettings();

      setAnalysisProgress(3, `Préparation…`);

      // 1) Collecter voies cyclables (+ option bus lanes)
      setAnalysisProgress(5, 'Collecte des tronçons cyclables…');
      const polylines = [];
      for (const el of lastFetchedElements) {
        if ((el.type === 'way' || el.type === 'relation') && el.geometry && el.geometry.length > 1) {
          const tags = el.tags || {};
          if (isCycleLike(tags) || (includeBus && isBusLaneLike(tags))) {
            polylines.push({ id: `${el.type}:${el.id}`, tags, geom: el.geometry });
          }
        }
      }
      if (polylines.length === 0) {
        setAnalysisProgress(100, 'Aucune voie cyclable/voies bus à analyser.');
        return;
      }

      // 2) Graphe (échantillonnage)
      setAnalysisProgress(12, `Construction du graphe (résolution ${sampleResolution} m)…`);
      const graph = new Map();
      const nodeCoord = new Map();
      function getNodeId(lat, lon, prec) { return `${Math.round(lat * prec)}_${Math.round(lon * prec)}`; }
      function ensureNode(lat, lon) {
        const id = getNodeId(lat, lon, precision);
        if (!graph.has(id)) graph.set(id, new Set());
        if (!nodeCoord.has(id)) nodeCoord.set(id, { lat, lon });
        return id;
      }

      let totalSegments = 0;
      for (const pl of polylines) totalSegments += Math.max(0, pl.geom.length - 1);

      let segProcessed = 0;
      for (let p = 0; p < polylines.length; p++) {
        const g = polylines[p].geom;
        for (let i = 0; i < g.length - 1; i++) {
          const start = { lat: g[i].lat, lon: g[i].lon };
          const end   = { lat: g[i+1].lat, lon: g[i+1].lon };

          const sampled = samplePointsOnSegment(start, end, sampleResolution);
          for (let j = 0; j < sampled.length - 1; j++) {
            const A = sampled[j], B = sampled[j+1];
            const idA = ensureNode(A.lat, A.lon);
            const idB = ensureNode(B.lat, B.lon);
            graph.get(idA).add(idB);
            graph.get(idB).add(idA);
          }

          segProcessed++;
          if ((segProcessed % 500) === 0) {
            setAnalysisProgress(12 + Math.floor(18 * segProcessed / Math.max(1, totalSegments)),
              `Construction du graphe… ${segProcessed}/${totalSegments}`);
            await new Promise(r => setTimeout(r, 0));
          }
        }
      }

      const allNodes = Array.from(nodeCoord.entries()).map(([id, { lat, lon }]) => ({ id, lat, lon }));
      setAnalysisProgress(30, `Noeuds générés: ${allNodes.length.toLocaleString('fr-FR')}`);

      // 3) Jointures virtuelles
      setAnalysisProgress(35, 'Jointure des points proches…');
      const centerLat = map.getCenter().lat;
      const degLatJoin = joinThreshold / 111320;
      const degLonJoin = joinThreshold / (111320 * Math.cos(centerLat * Math.PI / 180));
      function cellKey(lat, lon, dLat, dLon) {
        const x = Math.floor(lon / dLon);
        const y = Math.floor(lat / dLat);
        return `${x},${y}`;
      }
      const gridJoin = new Map();
      for (let i = 0; i < allNodes.length; i++) {
        const n = allNodes[i];
        const key = cellKey(n.lat, n.lon, degLatJoin, degLonJoin);
        if (!gridJoin.has(key)) gridJoin.set(key, []);
        gridJoin.get(key).push(i);
      }

      for (let i = 0; i < allNodes.length; i++) {
        const p = allNodes[i];
        const cx = Math.floor(p.lon / degLonJoin);
        const cy = Math.floor(p.lat / degLatJoin);
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            const arr = gridJoin.get(`${cx+dx},${cy+dy}`);
            if (!arr) continue;
            for (const j of arr) {
              if (j === i) continue;
              const q = allNodes[j];
              const d = haversine({ lat: p.lat, lon: p.lon }, { lat: q.lat, lon: q.lon });
              if (d <= joinThreshold) {
                graph.get(p.id).add(q.id);
                graph.get(q.id).add(p.id);
              }
            }
          }
        }
        if ((i % 2000) === 0) {
          setAnalysisProgress(35 + Math.floor(15 * i / Math.max(1, allNodes.length)), `Jointure… ${i}/${allNodes.length}`);
          await new Promise(r => setTimeout(r, 0));
        }
      }

      // 4) Composantes
      setAnalysisProgress(52, 'Recherche des réseaux…');
      const visited = new Set();
      const components = [];
      for (let idx = 0; idx < allNodes.length; idx++) {
        const startId = allNodes[idx].id;
        if (visited.has(startId)) continue;
        const comp = new Set();
        const q = [startId];
        visited.add(startId);
        while (q.length) {
          const cur = q.shift();
          comp.add(cur);
          graph.get(cur)?.forEach(n => { if (!visited.has(n)) { visited.add(n); q.push(n); } });
        }
        components.push(comp);
        if ((idx % 5000) === 0) {
          setAnalysisProgress(52 + Math.floor(10 * idx / Math.max(1, allNodes.length)), `Réseaux… ${idx}/${allNodes.length}`);
          await new Promise(r => setTimeout(r, 0));
        }
      }

      // 5) Index comp
      setAnalysisProgress(64, 'Préparation des réseaux…');
      const idToComp = new Map();
      components.forEach((comp, cid) => comp.forEach(n => idToComp.set(n, cid)));
      const nodesWithComp = allNodes.map(n => ({ ...n, compId: idToComp.get(n.id) }));

      // 6) Candidats
      setAnalysisProgress(68, 'Extraction des candidats de connexion…');
      const candidateSpacingMeters = Math.max(20, (parseFloat(advCandidateSpacing?.value) || 120));
      const compCandidates = components.map(comp =>
        findComponentConnectionPoints(
          comp, graph, nodeCoord,
          {
            capEndpoints: parseInt(advCapEndpoints?.value || 80, 10),
            maxInternalPerComponent: parseInt(advMaxInternalPerComp?.value || 60, 10),
            candidateSpacingMeters,
            centerLat,
            preferJunctions: !!advPreferJunctions?.checked
          }
        )
      );

      const idToIndex = new Map();
      nodesWithComp.forEach((n, i) => idToIndex.set(n.id, i));

      // 7) Appariement
      setAnalysisProgress(75, 'Recherche des gaps inter-réseaux…');
      const totalPairs = (components.length * (components.length - 1)) / 2;
      let pairCount = 0;
      const maxPairsPerCompPair = 2;

      const degLatGap = gapRadius / 111320;
      const degLonGap = gapRadius / (111320 * Math.cos(centerLat * Math.PI / 180));

      let suggestions = [];

      for (let a = 0; a < components.length; a++) {
        for (let b = a + 1; b < components.length; b++) {
          const A = compCandidates[a];
          const B = compCandidates[b];
          if (!A || !B || A.length === 0 || B.length === 0) { pairCount++; continue; }

          const pairs = greedyNearestUniquePairs(A, B, joinThreshold, gapRadius, degLatGap, degLonGap, maxPairsPerCompPair);
          for (const p of pairs) {
            const aNode = A[p.ai], bNode = B[p.bi];
            const i = idToIndex.get(aNode.id);
            const j = idToIndex.get(bNode.id);
            if (i != null && j != null) suggestions.push({ i, j, d: p.d });
          }

          pairCount++;
          if ((pairCount % 10) === 0) {
            const pct = 75 + Math.floor(10 * pairCount / Math.max(1, totalPairs));
            setAnalysisProgress(pct, `Gaps… ${pairCount}/${totalPairs}`);
            await new Promise(r => setTimeout(r, 0));
          }
        }
      }

      // 8) Nettoyage
      setAnalysisProgress(92, 'Nettoyage des suggestions…');
      const redundancyTolerance = 8; // m
      const C = components.length;
      const directEdge = Array.from({ length: C }, () => Array(C).fill(Infinity));
      for (let u = 0; u < C; u++) directEdge[u][u] = 0;

      for (const s of suggestions) {
        const u = nodesWithComp[s.i].compId;
        const v = nodesWithComp[s.j].compId;
        if (u === v) continue;
        if (s.d < directEdge[u][v]) {
          directEdge[u][v] = s.d;
          directEdge[v][u] = s.d;
        }
      }

      const distFW = directEdge.map(row => row.slice());
      for (let k = 0; k < C; k++) {
        for (let i = 0; i < C; i++) {
          const dik = distFW[i][k];
          if (!isFinite(dik)) continue;
          for (let j = 0; j < C; j++) {
            const alt = dik + distFW[k][j];
            if (alt < distFW[i][j]) distFW[i][j] = alt;
          }
        }
        if ((k % 10) === 0) await new Promise(r => setTimeout(r, 0));
      }

      const cleaned = [];
      for (const s of suggestions) {
        const u = nodesWithComp[s.i].compId;
        const v = nodesWithComp[s.j].compId;
        if (u === v) continue;
        const shortest = distFW[u][v];
        if (isFinite(shortest) && shortest + redundancyTolerance < s.d) continue;
        cleaned.push(s);
      }

      const bestByPair = new Map();
      for (const s of cleaned) {
        const u = nodesWithComp[s.i].compId;
        const v = nodesWithComp[s.j].compId;
        if (u === v) continue;
        const a = Math.min(u, v), b = Math.max(u, v);
        const key = `${a}|${b}`;
        const prev = bestByPair.get(key);
        if (!prev || s.d < prev.d) bestByPair.set(key, s);
      }
      suggestions = Array.from(bestByPair.values());

      // Filtre utilité
      const compSizes = components.map(c => c.size || 0);
      const maxComponentSize = compSizes.length ? Math.max(...compSizes) : 0;

      let displaySuggestions = suggestions;
      if (adv.enableConnectivityFilter) {
        displaySuggestions = suggestions.filter(s => {
          if (s.d <= joinThreshold + (parseFloat(advMinDistMargin?.value) || DEFAULT_GAP_FILTERS.minDistanceMarginMeters)) return false;
          const P = nodesWithComp[s.i], Q = nodesWithComp[s.j];
          const sizeA = compSizes[P.compId] || 0;
          const sizeB = compSizes[Q.compId] || 0;
          const coef = computeGapCoefficient(sizeA, sizeB, maxComponentSize, s.d, joinThreshold, gapRadius);
          return coef >= (parseFloat(advMinCoefficient?.value) || DEFAULT_GAP_FILTERS.minCoefficient);
        });
      }

      // 10) Affichage
      setAnalysisProgress(97, 'Affichage des gaps…');
      suggestionLines.forEach(l => map.removeLayer(l));
      suggestionLines = [];
      gapMarkers.forEach(m => map.removeLayer(m));
      gapMarkers = [];
      gapItems = [];

      const ordered = displaySuggestions.slice().sort((a, b) => a.d - b.d);
      ordered.forEach(s => {
        const P = nodesWithComp[s.i], Q = nodesWithComp[s.j];
        const compA = P.compId, compB = Q.compId;
        const sizeA = compSizes[compA] || 0;
        const sizeB = compSizes[compB] || 0;

        const coef = computeGapCoefficient(sizeA, sizeB, maxComponentSize, s.d, joinThreshold, gapRadius);
        const color = getGapColorFromCoeff(coef);

        const line = L.polyline([[P.lat, P.lon], [Q.lat, Q.lon]], {
          color,
          weight: GAP_STYLE_CONFIG.gapLineWeight,
          opacity: GAP_STYLE_CONFIG.lineOpacity,
          dashArray: GAP_STYLE_CONFIG.dashArray
        }).addTo(map);

        const mid = { lat: (P.lat + Q.lat) / 2, lon: (P.lon + Q.lon) / 2 };
        const marker = L.circleMarker([mid.lat, mid.lon], {
          radius: GAP_STYLE_CONFIG.gapMarkerRadius,
          color: color,
          weight: GAP_STYLE_CONFIG.gapMarkerBorderWeight,
          fillColor: color,
          fillOpacity: GAP_STYLE_CONFIG.gapMarkerFillOpacity
        }).addTo(map);

        const popupHtml = `
          <div style="font-family: system-ui, sans-serif; line-height:1.4;">
            <b>Gap suggéré</b><br/>
            Coefficient ≈ ${coef.toFixed(2)} (0–1)<br/>
            Distance ≈ ${Math.round(s.d)} m<br/>
            Réseaux: #${compA} (${sizeA} nœuds) ↔ #${compB} (${sizeB} nœuds)
          </div>
        `;
        marker.bindPopup(popupHtml);
        line.bindPopup(popupHtml);

        suggestionLines.push(line);
        gapMarkers.push(marker);

        gapItems.push({
          P, Q, compA, compB, sizeA, sizeB, distance: s.d, coef, color, line, marker
        });
      });

      gapCount.textContent = String(displaySuggestions.length);
      zoomGaps.disabled = displaySuggestions.length === 0;
      renderGapList(gapItems);

      if (components.length <= 1) {
        setAnalysisProgress(100, `Un seul réseau détecté ✔️`);
      } else {
        setAnalysisProgress(100, `${components.length} réseaux — ${displaySuggestions.length} gaps suggérés`);
      }
    }

    function renderGapList(items) {
      if (!items || items.length === 0) {
        gapListPanel.classList.add('hidden');
        gapListContent.innerHTML = '';
        gapListCount.textContent = '0';
        return;
      }
      const ordered = items.slice().sort((a, b) => b.coef - a.coef);

      gapListContent.innerHTML = ordered.map((item, idx) => {
        return `
          <button data-idx="${idx}"
                  class="w-full px-4 py-2 text-left hover:bg-gray-50 flex items-center gap-3">
            <span class="w-3 h-3 rounded-full" style="background:${item.color}"></span>
            <span class="font-medium text-gray-800">Coef ${item.coef.toFixed(2)}</span>
            <span class="text-gray-500 text-sm">— ${Math.round(item.distance)} m — #${item.compA} ↔ #${item.compB}</span>
          </button>
        `;
      }).join('');

      gapListPanel.classList.remove('hidden');
      gapListContent.classList.remove('hidden');
      gapListChevron.classList.add('rotate-180');
      gapListCount.textContent = String(items.length);

      Array.from(gapListContent.querySelectorAll('button[data-idx]')).forEach((btn, i) => {
        btn.addEventListener('click', () => {
          const item = ordered[i];
          if (!item) return;
          const bounds = L.latLngBounds([[item.P.lat, item.P.lon], [item.Q.lat, item.Q.lon]]);
          map.flyToBounds(bounds.pad(0.3), { maxZoom: 18, duration: 1.1 });
          setTimeout(() => item.marker.openPopup(), 1200);
        });
      });
    }

    // Docs Macros (affiche macros + sous-macros + alias)
    function renderMacroDocs() {
      const blocks = Object.entries(macros).map(([key, def]) => {
        const aliases = Object.entries(macroAliases).filter(([k,v]) => v === key).map(([k]) => k).join(', ');
        const docList = (def.doc || []).map(d => `<li><code>${d}</code></li>`).join('');

        let subs = '';
        if (def.subs) {
          subs = Object.entries(def.subs).map(([sk, sdef]) => {
            const sDoc = (sdef.doc || []).map(d => `<li><code>${d}</code></li>`).join('');
            // aliases vers sous-macro
            const subAliases = Object.entries(macroAliases).filter(([k,v]) => v === `${key}:${sk}`).map(([k]) => k).join(', ');
            return `
              <div class="mt-3 p-3 bg-gray-50 rounded-lg border border-gray-200">
                <div class="flex items-center justify-between">
                  <h4 class="font-semibold text-gray-800">${sdef.title || (def.title + ' — ' + sk)}</h4>
                  <span class="text-xs text-gray-500">alias: ${subAliases || '-'}</span>
                </div>
                <ul class="list-disc list-inside space-y-1 text-gray-700">${sDoc}</ul>
              </div>
            `;
          }).join('');
        }

        return `
          <div class="p-4 border border-gray-200 rounded-xl">
            <div class="flex items-center justify-between mb-2">
              <h3 class="text-lg font-semibold text-gray-800">${def.title}</h3>
              <span class="text-xs text-gray-500">alias: ${aliases || '-'}</span>
            </div>
            ${docList ? `<ul class="list-disc list-inside space-y-1 text-gray-700">${docList}</ul>` : ''}
            ${subs}
          </div>
        `;
      }).join('');
      macroDocsContent.innerHTML = blocks;
    }

    // ---- Écouteurs ----
    searchButton.addEventListener('click', handleSearch);
    searchInput.addEventListener('keydown', e => { if (e.key === 'Enter') handleSearch(); });

    fitButton.addEventListener('click', () => {
      if (featureLayers.length === 0) return;
      const group = L.featureGroup(featureLayers);
      map.fitBounds(group.getBounds().pad(0.1));
    });
    newSearchButton.addEventListener('click', () => {
      searchPanel.classList.remove('hidden');
      newSearchButton.classList.add('hidden');
      clearLayers();
      resultsCounter.classList.add('hidden');
      errorDisplay.classList.add('hidden');
      analysisPanel.classList.add('hidden');
    });

    document.getElementById('startAnalysis').addEventListener('click', runNetworkGapsAnalysis);
    document.getElementById('zoomGaps').addEventListener('click', () => {
      const all = [...suggestionLines, ...gapMarkers];
      if (all.length === 0) return;
      const grp = L.featureGroup(all);
      map.fitBounds(grp.getBounds().pad(0.2));
    });
    document.getElementById('clearGaps').addEventListener('click', () => {
      suggestionLines.forEach(l => map.removeLayer(l));
      suggestionLines = [];
      gapMarkers.forEach(m => map.removeLayer(m));
      gapMarkers = [];
      gapItems = [];
      gapCount.textContent = '0';
      zoomGaps.disabled = true;
      setAnalysisProgress(0, 'En attente…');
      gapListPanel.classList.add('hidden');
      gapListContent.classList.add('hidden');
      gapListChevron.classList.remove('rotate-180');
      gapListCount.textContent = '0';
      gapListContent.innerHTML = '';
    });

    advancedSettingsToggle.addEventListener('click', () => {
      advancedPanel.classList.toggle('hidden');
    });
    gapListToggle.addEventListener('click', () => {
      const hidden = gapListContent.classList.toggle('hidden');
      gapListChevron.classList.toggle('rotate-180', !hidden);
    });

    openMacroDocs.addEventListener('click', () => {
      renderMacroDocs();
      macroDocsModal.classList.remove('hidden');
    });
    closeMacroDocs.addEventListener('click', () => macroDocsModal.classList.add('hidden'));
    macroDocsModal.addEventListener('click', (e) => { if (e.target === macroDocsModal) macroDocsModal.classList.add('hidden'); });
  </script>
</body>
</html>
