<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>OSM Data Explorer</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <!-- Font Awesome + Awesome Markers -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.css"/>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    #map { height: 100vh; width: 100%; z-index: 0; }
    .search-panel {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      z-index: 1000; max-width: 64rem; width: 90%; max-height: 90vh; overflow-y: auto;
    }
    .loading-overlay {
      position: absolute; inset: 0; background: rgba(0,0,0,.2); backdrop-filter: blur(4px);
      display: flex; align-items: center; justify-content: center; z-index: 2000;
    }
    .spinner {
      border: 4px solid #f3f3f3; border-top: 4px solid #6366f1; border-radius: 50%;
      width: 48px; height: 48px; animation: spin 1s linear infinite;
    }
    @keyframes spin { 0% { transform: rotate(0deg) } 100% { transform: rotate(360deg) } }
    .hidden { display: none }
    .leaflet-popup-content-wrapper { border-radius: 12px }

    /* Barre de progression (analyse) */
    .progress-bar { height: 8px; background: #e5e7eb; border-radius: 8px; overflow: hidden; }
    .progress-bar > div { height: 100%; background: linear-gradient(90deg, #22c55e, #3b82f6); width: 0%; transition: width .2s ease; }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-gray-50 via-white to-blue-50">
  <!-- Header -->
  <header class="bg-gradient-to-r from-indigo-600 via-purple-600 to-pink-600 text-white shadow-2xl p-6 md:p-8 relative z-10">
    <div class="max-w-7xl mx-auto text-center md:text-left">
      <h1 class="text-3xl md:text-5xl font-black mb-2 drop-shadow-lg">üåç OSM Data Explorer</h1>
      <p class="text-lg md:text-xl opacity-95 max-w-3xl mx-auto md:mx-0 leading-relaxed">
        D√©crivez ce que vous voulez voir (points, lignes, r√©seaux) et regardez-le appara√Ætre sur la carte.
      </p>
      <p class="text-sm md:text-base mt-4 opacity-80 italic">
        Donn√©es en temps r√©el via Overpass. Le zoom s'ajuste automatiquement.
      </p>
    </div>
  </header>

  <!-- Bouton Nouvelle Recherche -->
  <button id="newSearchButton"
          class="hidden absolute top-28 left-4 z-[1000] bg-white/90 backdrop-blur-md shadow-lg rounded-lg p-3 text-gray-700 font-semibold hover:bg-gray-50 transition-transform hover:scale-105">
    <i class="fa-solid fa-magnifying-glass mr-2"></i> Nouvelle Recherche
  </button>

  <!-- Map -->
  <div id="map"></div>

  <!-- Search Panel -->
  <div class="search-panel">
    <div class="bg-white/95 backdrop-blur-xl rounded-3xl shadow-2xl border border-white/50 p-6 md:p-8">
      <div class="space-y-6">
        <div>
          <label class="block text-gray-800 text-xl font-bold mb-4 text-center md:text-left">
            üîç Que voulez-vous explorer?
          </label>
          <input id="searchInput" type="text"
                 value="cycleway et r√©seaux d'eau in Bordeaux"
                 class="w-full px-6 py-4 text-lg bg-gradient-to-r from-gray-50 to-blue-50 border-2 border-gray-300 rounded-2xl focus:outline-none focus:ring-4 focus:ring-indigo-500 focus:border-transparent shadow-xl transition-all duration-300 placeholder-gray-500 font-medium"
                 placeholder="Ex: r√©seaux d'eau in Lyon, r√©seaux de transports in Paris, bus lanes in Toulouse, zone commerciale in Nantes"/>
        </div>

        <button id="searchButton"
                class="w-full py-4 px-8 bg-gradient-to-r from-emerald-500 via-teal-500 to-cyan-500 text-white font-extrabold text-lg rounded-2xl shadow-2xl hover:shadow-3xl transform hover:scale-105 active:scale-95 transition-all duration-300 flex items-center justify-center gap-3 uppercase tracking-wide">
          üöÄ Lancer la recherche
        </button>

        <div id="errorDisplay" class="hidden p-6 bg-gradient-to-r from-red-50 to-pink-50 border-2 border-red-200 rounded-2xl shadow-md">
          <div class="flex items-center gap-3 mb-2">
            <span class="text-2xl">‚ö†Ô∏è</span>
            <h3 class="font-bold text-red-800 text-lg">Probl√®me de requ√™te</h3>
          </div>
          <p id="errorMessage" class="text-red-700 leading-relaxed whitespace-pre-wrap"></p>
        </div>

        <div class="p-4 bg-blue-50/50 border border-blue-200 rounded-2xl text-sm md:text-base space-y-2">
          <p class="font-semibold text-blue-800 flex items-center gap-2">üìã Sujets support√©s (combinez-les!)</p>
          <p class="text-blue-700">
            Points: bus, stop, school, university, college, restaurant, cafe, bar, park, hospital, clinic, shop, store, atm, bank, hotel,
            fountain, swimming_pool
          </p>
          <p class="text-blue-700">
            Lignes/Surfaces: cycleway, footway, sidewalk, path, river, stream, canal, drain, ditch, wetlands, lake, pond, reservoir, basin
          </p>
          <p class="text-blue-700">
            Macros: r√©seaux d'eau, r√©seaux de transports, bus lanes, zone commerciale, zone r√©sidentielle
          </p>
          <p class="text-gray-600 text-xs italic">‚Äúand‚Äù ou ‚Äúet‚Äù fonctionnent. Ex: cycleway et r√©seaux d'eau in Paris.</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Results Counter -->
  <div id="resultsCounter" class="hidden absolute bottom-6 right-6 z-30">
    <div class="bg-white/95 backdrop-blur-xl rounded-2xl shadow-2xl p-4 md:p-6 border border-gray-200/50 space-y-3 min-w-[220px]">
      <div class="flex items-center justify-between gap-2 mb-3">
        <span class="text-2xl font-bold text-green-600">üéØ</span>
        <span id="resultCount" class="text-lg font-bold text-gray-800">0</span>
        <span class="text-sm text-gray-600">√©l√©ments</span>
      </div>
      <button id="fitButton"
              class="w-full py-3 px-4 bg-gradient-to-r from-blue-500 to-indigo-600 text-white font-semibold rounded-xl shadow-lg hover:shadow-xl transform hover:scale-105 transition-all duration-200 flex items-center justify-center gap-2 text-sm uppercase tracking-wide">
        üìê Ajuster aux √©l√©ments
      </button>
    </div>
  </div>

  <!-- Analyse Discontinuit√©s Panel -->
  <div id="analysisPanel" class="hidden absolute bottom-6 left-6 z-30">
    <div class="bg-white/95 backdrop-blur-xl rounded-2xl shadow-2xl p-4 md:p-5 border border-gray-200/50 space-y-3 min-w-[260px]">
      <div class="flex items-center gap-2">
        <span class="text-xl">üö¥</span>
        <h3 class="font-bold text-gray-800">Discontinuit√©s cyclables</h3>
      </div>
      <div class="flex items-center gap-2 text-sm">
        <input id="includeBusLanes" type="checkbox" class="w-4 h-4">
        <label for="includeBusLanes" class="text-gray-700">Inclure les voies bus</label>
      </div>
      <button id="startAnalysis"
              class="w-full py-2.5 px-4 bg-gradient-to-r from-rose-500 to-orange-500 text-white font-semibold rounded-xl shadow hover:shadow-md transition">
        Analyser
      </button>
      <div id="analysisStatus" class="text-xs text-gray-600">En attente‚Ä¶</div>
      <div class="progress-bar"><div id="analysisProgress" style="width:0%"></div></div>
      <div class="flex gap-2">
        <button id="zoomGaps" class="flex-1 py-2 px-3 bg-blue-600 text-white rounded-lg text-sm disabled:opacity-50" disabled>Zoom sur gaps</button>
        <button id="clearGaps" class="flex-1 py-2 px-3 bg-gray-200 text-gray-800 rounded-lg text-sm">Effacer</button>
      </div>
      <div class="text-sm"><span class="font-semibold">Gaps trouv√©s:</span> <span id="gapCount">0</span></div>
    </div>
  </div>

  <!-- Loading -->
  <div id="loadingOverlay" class="loading-overlay hidden">
    <div class="bg-white/90 backdrop-blur-xl rounded-3xl p-8 shadow-3xl text-center space-y-4 border-2 border-indigo-200">
      <div class="spinner"></div>
      <p class="text-xl font-semibold text-gray-700">R√©cup√©ration des donn√©es OpenStreetMap...</p>
      <p class="text-sm text-gray-500" id="downloadStatus">T√©l√©chargement‚Ä¶</p>
    </div>
  </div>

  <!-- Scripts -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.min.js"></script>

  <script>
    // Helpers: normalisation + remplacements FR/EN
    function normalize(str) {
      return (str || '')
        .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
        .toLowerCase();
    }
    function preprocessTopics(text) {
      let s = normalize(text);
      // Unifier le s√©parateur (and/et -> ,)
      s = s.replace(/\s+(?:and|et)\s+/g, ',');
      // Macros FR
      s = s.replace(/\breseaux?\s+d'?eaux?\b/g, 'reseaux_eau');
      s = s.replace(/\breseaux?\s+de\s+transports?\b/g, 'reseaux_transports');
      s = s.replace(/\b(voies?|bandes?|couloirs?)\s+(de\s+)?bus\b/g, 'bus_lanes');
      s = s.replace(/\bpistes?\s+cyclables?\b/g, 'cycleway');
      // EN equivalences
      s = s.replace(/\bwater\s+networks?\b/g, 'reseaux_eau');
      s = s.replace(/\btransport\s+networks?\b/g, 'reseaux_transports');
      s = s.replace(/\bbus\s+lanes?\b/g, 'bus_lanes');
      s = s.replace(/\bcommercial\s+zone\b/g, 'zone_commerciale');
      s = s.replace(/\bresidential\s+zone\b/g, 'zone_residentielle');
      return s;
    }

    // Sujet ‚Üí d√©finitions {type: node|way|relation, filter: '[...]'}
    const topics = {
      // Points
      bus:        [{ type: 'node', filter: '["highway"="bus_stop"]' }],
      stop:       [{ type: 'node', filter: '["highway"="bus_stop"]' }],
      school:     [{ type: 'node', filter: '["amenity"="school"]' }],
      university: [{ type: 'node', filter: '["amenity"="university"]' }],
      college:    [{ type: 'node', filter: '["amenity"="college"]' }],
      restaurant: [{ type: 'node', filter: '["amenity"="restaurant"]' }],
      cafe:       [{ type: 'node', filter: '["amenity"="cafe"]' }],
      bar:        [{ type: 'node', filter: '["amenity"="bar"]' }],
      hospital:   [{ type: 'node', filter: '["amenity"="hospital"]' }],
      clinic:     [{ type: 'node', filter: '["amenity"="clinic"]' }],
      shop:       [{ type: 'node', filter: '[shop]' }],
      store:      [{ type: 'node', filter: '[shop]' }],
      atm:        [{ type: 'node', filter: '["amenity"="atm"]' }],
      bank:       [{ type: 'node', filter: '["amenity"="bank"]' }],
      hotel:      [{ type: 'node', filter: '["tourism"="hotel"]' }],
      fountain:   [{ type: 'node', filter: '["amenity"="fountain"]' }, { type: 'way', filter: '["amenity"="fountain"]' }],
      swimming_pool: [
        { type: 'node', filter: '["leisure"="swimming_pool"]' },
        { type: 'way', filter: '["leisure"="swimming_pool"]' },
        { type: 'relation', filter: '["leisure"="swimming_pool"]["type"="multipolygon"]' },
      ],
      // Parcs
      park: [
        { type: 'way',      filter: '["leisure"="park"]' },
        { type: 'relation', filter: '["leisure"="park"]["type"="multipolygon"]' }
      ],

      // Cycleways (√©largi)
      cycleway: [
        { type: 'way', filter: '["highway"="cycleway"]' },
        { type: 'way', filter: '[~"^cycleway"~"."]' },
        { type: 'way', filter: '["bicycle_road"="yes"]' },
        { type: 'way', filter: '["highway"="path"]["bicycle"~"^(designated|official)$"]' },
        { type: 'way', filter: '["highway"="footway"]["bicycle"~"^(designated|official)$"]' }
      ],
      footway:    [{ type: 'way',  filter: '["highway"="footway"]' }],
      sidewalk:   [{ type: 'way',  filter: '["highway"="footway"]["footway"="sidewalk"]' }],
      path:       [{ type: 'way',  filter: '["highway"="path"]' }],
      pathway:    [{ type: 'way',  filter: '["highway"="path"]' }],

      // Bus lanes (pas d'arr√™ts bus ici)
      bus_lanes: [
        { type: 'way', filter: '["highway"="busway"]' },
        { type: 'way', filter: '[~"^busway(:|$)"~"."]' },
        { type: 'way', filter: '[~"^bus:lanes"~"."]' },
        { type: 'way', filter: '["psv"="designated"]' },
        { type: 'way', filter: '["bus"="designated"]' },
        { type: 'way', filter: '["access"="no"]["psv"="yes"]' },
        { type: 'way', filter: '["access"="no"]["bus"="yes"]' }
      ],

      // R√©seaux d'eau (sans fontaines ni piscines)
      reseaux_eau: [
        // Lignes d'eau
        { type: 'way', filter: '["waterway"~"^(river|stream|canal|drain|ditch|wadi)$"]' },
        // Surfaces d'eau (ways + relations)
        { type: 'way',      filter: '["natural"="water"]' },
        { type: 'relation', filter: '["natural"="water"]["type"="multipolygon"]' },
        { type: 'way',      filter: '["waterway"="riverbank"]' },
        { type: 'relation', filter: '["waterway"="riverbank"]["type"="multipolygon"]' },
        { type: 'way',      filter: '["landuse"~"^(reservoir|basin)$"]' },
        { type: 'relation', filter: '["landuse"~"^(reservoir|basin)$"]["type"="multipolygon"]' },
        // Zones humides
        { type: 'way',      filter: '["natural"="wetland"]' },
        { type: 'relation', filter: '["natural"="wetland"]["type"="multipolygon"]' },
        // Ouvrages/equipements (sans fontaines)
        { type: 'node', filter: '["natural"="spring"]' },
        { type: 'node', filter: '["man_made"~"^(water_tower|pumping_station|reservoir_covered|water_well|wastewater_plant)$"]' },
        { type: 'way',  filter: '["man_made"~"^(dam|water_tower|pumping_station|reservoir_covered|wastewater_plant)$"]' },
        { type: 'way',  filter: '["waterway"~"^(weir|lock_gate|sluice_gate)$"]' },
        // D√©tails water=*
        { type: 'way',      filter: '["natural"="water"]["water"~"^(lake|pond|reservoir|basin|lagoon|oxbow|canal|river|stream|wastewater)$"]' },
        { type: 'relation', filter: '["natural"="water"]["water"~"^(lake|pond|reservoir|basin|lagoon|oxbow|canal|river|stream|wastewater)$"]["type"="multipolygon"]' },
        // Littoral
        { type: 'way', filter: '["natural"="coastline"]' }
      ],
      // Cours d'eau individuels
      river:  [{ type: 'way', filter: '["waterway"="river"]' }],
      stream: [{ type: 'way', filter: '["waterway"="stream"]' }],
      canal:  [{ type: 'way', filter: '["waterway"="canal"]' }],
      drain:  [{ type: 'way', filter: '["waterway"="drain"]' }],
      ditch:  [{ type: 'way', filter: '["waterway"="ditch"]' }],
      wetlands:[{ type: 'way', filter: '["natural"="wetland"]' }, { type: 'relation', filter: '["natural"="wetland"]["type"="multipolygon"]' }],
      lake: [
        { type: 'way', filter: '["natural"="water"]["water"="lake"]' },
        { type: 'relation', filter: '["natural"="water"]["water"="lake"]["type"="multipolygon"]' }
      ],
      pond: [
        { type: 'way', filter: '["natural"="water"]["water"="pond"]' },
        { type: 'relation', filter: '["natural"="water"]["water"="pond"]["type"="multipolygon"]' }
      ],
      reservoir: [
        { type: 'way', filter: '["natural"="water"]["water"="reservoir"]' },
        { type: 'relation', filter: '["natural"="water"]["water"="reservoir"]["type"="multipolygon"]' },
        { type: 'way', filter: '["landuse"="reservoir"]' },
        { type: 'relation', filter: '["landuse"="reservoir"]["type"="multipolygon"]' }
      ],
      basin: [
        { type: 'way', filter: '["natural"="water"]["water"="basin"]' },
        { type: 'relation', filter: '["natural"="water"]["water"="basin"]["type"="multipolygon"]' },
        { type: 'way', filter: '["landuse"="basin"]' },
        { type: 'relation', filter: '["landuse"="basin"]["type"="multipolygon"]' }
      ],

      // R√©seaux de transports (all√©g√© pour √©viter timeouts) ‚Üí seulement des ways
      reseaux_transports: [
        { type: 'way', filter: '["railway"~"^(rail|tram|light_rail|subway|narrow_gauge|monorail|funicular)$"]' },
        { type: 'way', filter: '[~"^aerialway"~"."]' },
        { type: 'way', filter: '["highway"="busway"]' },
        { type: 'way', filter: '[~"^busway(:|$)"~"."]' },
        { type: 'way', filter: '[~"^bus:lanes"~"."]' }
      ],

      // Zones d'analyse urbaine
      zone_commerciale: [
        { type: 'way',      filter: '["landuse"~"^(industrial|commercial|retail)$"]' },
        { type: 'relation', filter: '["landuse"~"^(industrial|commercial|retail)$"]["type"="multipolygon"]' },
        { type: 'way',      filter: '["man_made"="works"]' },
        { type: 'relation', filter: '["man_made"="works"]["type"="multipolygon"]' }
      ],
      zone_residentielle: [
        { type: 'way',      filter: '["landuse"="residential"]' },
        { type: 'relation', filter: '["landuse"="residential"]["type"="multipolygon"]' },
        { type: 'way',      filter: '["building"~"^(residential|apartments|house|detached|terrace|semidetached_house)$"]' }
      ]
    };

    // Carte
    const map = L.map('map').setView([48.8566, 2.3522], 12);
    L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; OpenStreetMap &copy; CARTO'
    }).addTo(map);

    // √âtat
    let featureLayers = [];
    let gapMarkers = [];
    let lastFetchedElements = []; // pour l'analyse

    // DOM
    const searchInput = document.getElementById('searchInput');
    const searchButton = document.getElementById('searchButton');
    const errorDisplay = document.getElementById('errorDisplay');
    const errorMessage = document.getElementById('errorMessage');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const downloadStatus = document.getElementById('downloadStatus');
    const resultsCounter = document.getElementById('resultsCounter');
    const resultCount = document.getElementById('resultCount');
    const fitButton = document.getElementById('fitButton');
    const searchPanel = document.querySelector('.search-panel');
    const newSearchButton = document.getElementById('newSearchButton');

    const analysisPanel = document.getElementById('analysisPanel');
    const startAnalysis = document.getElementById('startAnalysis');
    const analysisProgress = document.getElementById('analysisProgress');
    const analysisStatus = document.getElementById('analysisStatus');
    const gapCount = document.getElementById('gapCount');
    const zoomGaps = document.getElementById('zoomGaps');
    const clearGapsBtn = document.getElementById('clearGaps');
    const includeBusLanes = document.getElementById('includeBusLanes');

    // Ic√¥nes pour les points
    function getIconForFeature(tags) {
      if (tags.highway === 'bus_stop') return L.AwesomeMarkers.icon({ icon: 'bus', prefix: 'fa', markerColor: 'blue' });
      if (['school','college','university'].includes(tags.amenity)) return L.AwesomeMarkers.icon({ icon: 'school', prefix: 'fa', markerColor: 'green' });
      if (tags.amenity === 'restaurant') return L.AwesomeMarkers.icon({ icon: 'utensils', prefix: 'fa', markerColor: 'orange' });
      if (tags.amenity === 'cafe') return L.AwesomeMarkers.icon({ icon: 'coffee', prefix: 'fa', markerColor: 'cadetblue' });
      if (tags.amenity === 'bar') return L.AwesomeMarkers.icon({ icon: 'martini-glass', prefix: 'fa', markerColor: 'darkred' });
      if (tags.amenity === 'hospital' || tags.amenity === 'clinic') return L.AwesomeMarkers.icon({ icon: 'kit-medical', prefix: 'fa', markerColor: 'red' });
      if (tags.shop) return L.AwesomeMarkers.icon({ icon: 'store', prefix: 'fa', markerColor: 'purple' });
      if (tags.amenity === 'bank') return L.AwesomeMarkers.icon({ icon: 'building-columns', prefix: 'fa', markerColor: 'blue' });
      if (tags.amenity === 'atm') return L.AwesomeMarkers.icon({ icon: 'money-bill-wave', prefix: 'fa', markerColor: 'darkgreen' });
      if (tags.tourism === 'hotel') return L.AwesomeMarkers.icon({ icon: 'bed', prefix: 'fa', markerColor: 'cadetblue' });
      if (tags.leisure === 'park') return L.AwesomeMarkers.icon({ icon: 'tree', prefix: 'fa', markerColor: 'darkgreen' });
      if (tags.natural === 'spring') return L.AwesomeMarkers.icon({ icon: 'tint', prefix: 'fa', markerColor: 'darkblue' });
      if (tags.amenity === 'fountain') return L.AwesomeMarkers.icon({ icon: 'faucet', prefix: 'fa', markerColor: 'blue' });
      return L.AwesomeMarkers.icon({ icon: 'info-circle', prefix: 'fa', markerColor: 'gray' });
    }

    // Style des lignes/polygones
    function getStyleForFeature(tags) {
      // Pistes / Chemins
      if (tags.highway === 'cycleway' || Object.keys(tags).some(k => /^cycleway/.test(k))) return { color: '#e11d48', weight: 3, opacity: 0.95 };
      if (tags.highway === 'footway')  return { color: '#8b5e3c', weight: 3, opacity: 0.9, dashArray: '6,4' };
      if (tags.highway === 'path')     return { color: '#7c3aed', weight: 3, opacity: 0.9, dashArray: '8,4' };

      // Voies bus
      if (tags.highway === 'busway' || 'busway' in tags || Object.keys(tags).some(k => k.startsWith('bus:lanes'))) return { color: '#f59e0b', weight: 4, opacity: 0.95 };

      // Cours d'eau
      if (tags.waterway === 'river')   return { color: '#1d4ed8', weight: 4, opacity: 0.9 };
      if (tags.waterway === 'canal')   return { color: '#0ea5e9', weight: 4, opacity: 0.9 };
      if (tags.waterway === 'stream')  return { color: '#60a5fa', weight: 3, opacity: 0.9 };
      if (tags.waterway === 'drain')   return { color: '#38bdf8', weight: 2.5, opacity: 0.9, dashArray: '4,3' };
      if (tags.waterway === 'ditch')   return { color: '#93c5fd', weight: 2.5, opacity: 0.9, dashArray: '4,3' };
      if (['weir','lock_gate','sluice_gate'].includes(tags.waterway)) return { color: '#22d3ee', weight: 2.5, opacity: 0.9, dashArray: '2,4' };

      // Surfaces d'eau / zones humides / parcs
      if (tags.natural === 'water' || tags.water || tags.landuse === 'reservoir' || tags.natural === 'wetland' || tags.waterway === 'riverbank') {
        return { color: '#38bdf8', weight: 2, opacity: 0.8, fill: true, fillColor: '#93c5fd', fillOpacity: 0.35 };
      }
      if (tags.leisure === 'park')     return { color: '#16a34a', weight: 2, opacity: 0.8, fill: true, fillColor: '#86efac', fillOpacity: 0.25 };

      // Rail / Aerialway / Transports
      if (tags.railway)   return { color: '#6b7280', weight: 3, opacity: 0.9, dashArray: '6,3' };
      if (tags.aerialway) return { color: '#fb7185', weight: 3, opacity: 0.9, dashArray: '4,4' };

      // Zones
      if (tags.landuse === 'industrial' || tags.landuse === 'commercial' || tags.landuse === 'retail') {
        return { color: '#f97316', weight: 2, fill: true, fillColor: '#fdba74', fillOpacity: 0.25 };
      }
      if (tags.landuse === 'residential') {
        return { color: '#22c55e', weight: 2, fill: true, fillColor: '#86efac', fillOpacity: 0.25 };
      }

      return { color: '#555', weight: 2, opacity: 0.8 };
    }

    // Parsing "topics in city"
    function parseQuery(q) {
      const lower = q.toLowerCase().trim();
      const m = lower.match(/(.+?)\s+in\s+(.+)$/i);
      if (!m) throw new Error('Format attendu: "sujets in ville" (ex: cycleway et r√©seaux d\'eau in Toulouse)');
      const topicRaw = m[1];
      const city = m[2].trim();
      if (!city) throw new Error('La ville est requise.');

      const normalized = preprocessTopics(topicRaw);
      const words = normalized.split(/[,\s;+/]+/).map(w => w.trim()).filter(Boolean);

      const nodeFilters = new Set();
      const wayFilters  = new Set();
      const relFilters  = new Set();

      words.forEach(w => {
        const defs = topics[w];
        if (defs) defs.forEach(d => {
          if (d.type === 'node') nodeFilters.add(d.filter);
          else if (d.type === 'way') wayFilters.add(d.filter);
          else if (d.type === 'relation') relFilters.add(d.filter);
        });
      });

      if (nodeFilters.size === 0 && wayFilters.size === 0 && relFilters.size === 0) {
        throw new Error(`Aucun sujet reconnu dans "${topicRaw}".`);
      }
      return {
        nodeFilters: Array.from(nodeFilters),
        wayFilters: Array.from(wayFilters),
        relFilters: Array.from(relFilters),
        city
      };
    }

    function clearLayers() {
      featureLayers.forEach(l => map.removeLayer(l));
      featureLayers = [];
      gapMarkers.forEach(m => map.removeLayer(m));
      gapMarkers = [];
      lastFetchedElements = [];
      gapCount.textContent = '0';
      zoomGaps.disabled = true;
    }

    function isClosedPolygon(geom) {
      if (!geom || geom.length < 4) return false;
      const a = geom[0], b = geom[geom.length - 1];
      return Math.abs(a.lat - b.lat) < 1e-9 && Math.abs(a.lon - b.lon) < 1e-9;
    }

    // T√©l√©chargement Overpass par lots pour √©viter les timeouts
    async function fetchOverpassBatches(bbox, nodeFilters, wayFilters, relFilters, onBatchProgress) {
      // Construire tous les statements
      const statements = [];
      nodeFilters.forEach(f => statements.push(`node${f}(${bbox});`));
      wayFilters.forEach(f => statements.push(`way${f}(${bbox});`));
      relFilters.forEach(f => statements.push(`relation${f}(${bbox});`));

      const maxPerBatch = 18; // limiter la complexit√© de chaque requ√™te
      const batches = [];
      for (let i = 0; i < statements.length; i += maxPerBatch) {
        batches.push(statements.slice(i, i + maxPerBatch));
      }

      const elementsMap = new Map(); // de-dup: key = type:id
      for (let i = 0; i < batches.length; i++) {
        const parts = batches[i].join('\n  ');
        const query = `[out:json][timeout:180];
(
  ${parts}
);
out geom;`;
        const opUrl = 'https://overpass-api.de/api/interpreter';
        const res = await fetch(opUrl, { method: 'POST', body: `data=${encodeURIComponent(query)}` });
        if (!res.ok) {
          const body = await res.text();
          throw new Error(`Erreur API Overpass: ${res.status} ${res.statusText}. ${body.substring(0,200)}`);
        }
        const json = await res.json();
        (json.elements || []).forEach(el => {
          const key = `${el.type}:${el.id}`;
          if (!elementsMap.has(key)) elementsMap.set(key, el);
        });
        if (onBatchProgress) onBatchProgress(i + 1, batches.length);
      }
      return Array.from(elementsMap.values());
    }

    async function handleSearch() {
      errorDisplay.classList.add('hidden');
      clearLayers();
      loadingOverlay.classList.remove('hidden');
      resultsCounter.classList.add('hidden');
      analysisPanel.classList.add('hidden');
      downloadStatus.textContent = 'T√©l√©chargement‚Ä¶';

      try {
        const { nodeFilters, wayFilters, relFilters, city } = parseQuery(searchInput.value);

        // G√©ocodage
        const nomUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(city)}&limit=1&addressdetails=1`;
        const nomRes = await fetch(nomUrl);
        if (!nomRes.ok) throw new Error('√âchec du g√©ocodage');
        const nomData = await nomRes.json();
        if (nomData.length === 0) throw new Error(`Aucun lieu trouv√© pour '${city}'.`);

        const place = nomData[0];
        const [south, north, west, east] = place.boundingbox.map(parseFloat);
        const bbox = `${south},${west},${north},${east}`;
        map.fitBounds([[south, west], [north, east]]);

        // T√©l√©chargement par lots avec progression
        let lastBatch = 0;
        const elements = await fetchOverpassBatches(bbox, nodeFilters, wayFilters, relFilters, (done, total) => {
          lastBatch = done;
          downloadStatus.textContent = `T√©l√©chargement ${done}/${total}‚Ä¶`;
        });

        // Affichage des √©l√©ments
        elements.forEach(el => {
          const tags = el.tags || {};
          const name = tags.name || '√âl√©ment sans nom';
          let layer;

          // Popup
          let popup = `<div style="font-family: system-ui, sans-serif; line-height:1.4;">
            <h3 style="font-size:16px;font-weight:700;margin-bottom:8px;">${name}</h3>
            <div style="font-size:13px;max-height:150px;overflow-y:auto;">`;
          Object.entries(tags).forEach(([k, v]) => { popup += `<div><strong>${k}:</strong> ${v}</div>`; });
          popup += `</div></div>`;

          if (el.type === 'node' && el.lat && el.lon) {
            layer = L.marker([el.lat, el.lon], { icon: getIconForFeature(tags) }).addTo(map);
          } else if ((el.type === 'way' || el.type === 'relation') && el.geometry && el.geometry.length > 1) {
            const latLngs = el.geometry.map(pt => [pt.lat, pt.lon]);
            // Polygone si ferm√© + tags surface/zone
            if (isClosedPolygon(el.geometry) && (tags.natural === 'water' || tags.landuse === 'reservoir' || tags.natural === 'wetland' || tags.leisure === 'park' || tags.waterway === 'riverbank' || tags.landuse === 'residential' || ['industrial','commercial','retail'].includes(tags.landuse))) {
              const style = getStyleForFeature(tags);
              layer = L.polygon(latLngs, { ...style }).addTo(map);
            } else {
              const style = getStyleForFeature(tags);
              layer = L.polyline(latLngs, style).addTo(map);
            }
          }

          if (layer) {
            layer.bindPopup(popup, { maxWidth: 320 });
            featureLayers.push(layer);
          }
        });

        lastFetchedElements = elements; // pour l'analyse
        if (featureLayers.length > 0) {
          resultCount.textContent = featureLayers.length;
          resultsCounter.classList.remove('hidden');
        }

        // UI
        searchPanel.classList.add('hidden');
        newSearchButton.classList.remove('hidden');
        analysisPanel.classList.remove('hidden');

      } catch (err) {
        errorMessage.textContent = err.message || 'Erreur inconnue.';
        errorDisplay.classList.remove('hidden');
      } finally {
        loadingOverlay.classList.add('hidden');
      }
    }

    // ---- Analyse Dangling Ends (in-browser) ----
    function toRad(x) { return x * Math.PI / 180; }
    function haversine(a, b) {
      const R = 6371000;
      const dLat = toRad(b.lat - a.lat);
      const dLon = toRad(b.lon - a.lon);
      const lat1 = toRad(a.lat);
      const lat2 = toRad(b.lat);
      const s = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
      return 2 * R * Math.asin(Math.sqrt(s));
    }

    function isCycleLike(tags) {
      return tags.highway === 'cycleway'
        || Object.keys(tags).some(k => /^cycleway/.test(k))
        || tags.bicycle_road === 'yes'
        || (tags.highway === 'path' && /^(designated|official)$/.test(tags.bicycle||''))
        || (tags.highway === 'footway' && /^(designated|official)$/.test(tags.bicycle||''));
    }
    function isBusLaneLike(tags) {
      return tags.highway === 'busway' || 'busway' in tags || Object.keys(tags).some(k => k.startsWith('bus:lanes')) || tags.bus === 'designated' || tags.psv === 'designated';
    }

    function setAnalysisProgress(pct, msg) {
      analysisProgress.style.width = `${Math.min(100, Math.max(0, pct))}%`;
      analysisStatus.textContent = msg;
    }

    async function runDanglingAnalysis() {
      if (!lastFetchedElements || lastFetchedElements.length === 0) {
        analysisStatus.textContent = "Aucun r√©seau charg√©.";
        return;
      }
      // Param√®tres
      const includeBus = includeBusLanes.checked;
      const thresholdMeters = 15; // rayon de jonction
      const deltaLat = thresholdMeters / 111320; // ‚âà deg lat
      const centerLat = map.getCenter().lat;
      const deltaLon = thresholdMeters / (111320 * Math.cos(centerLat * Math.PI / 180));

      // 1) Collecter les polylines pertinentes
      setAnalysisProgress(5, 'Collecte des tron√ßons‚Ä¶');
      const polylines = [];
      lastFetchedElements.forEach(el => {
        if ((el.type === 'way' || el.type === 'relation') && el.geometry && el.geometry.length > 1) {
          const tags = el.tags || {};
          if (isCycleLike(tags) || (includeBus && isBusLaneLike(tags))) {
            polylines.push({ id: `${el.type}:${el.id}`, tags, geom: el.geometry });
          }
        }
      });
      if (polylines.length === 0) {
        setAnalysisProgress(100, 'Aucune voie cyclable/voies bus √† analyser.');
        return;
      }

      // 2) Extraire endpoints (sauter polygones ferm√©s)
      setAnalysisProgress(15, 'Extraction des extr√©mit√©s‚Ä¶');
      const endpoints = []; // {lat, lon, id, which:0/1}
      for (const pl of polylines) {
        const g = pl.geom;
        if (isClosedPolygon(g)) continue;
        const a = g[0], b = g[g.length - 1];
        endpoints.push({ lat: a.lat, lon: a.lon, id: pl.id, which: 0 });
        endpoints.push({ lat: b.lat, lon: b.lon, id: pl.id, which: 1 });
      }
      if (endpoints.length === 0) {
        setAnalysisProgress(100, 'Aucune extr√©mit√© d√©tect√©e.');
        return;
      }

      // 3) Index en grille pour endpoints
      setAnalysisProgress(30, 'Indexation‚Ä¶');
      const grid = new Map();
      function cellKey(lat, lon) {
        const x = Math.floor(lon / deltaLon);
        const y = Math.floor(lat / deltaLat);
        return `${x},${y}`;
      }
      endpoints.forEach((p, i) => {
        const key = cellKey(p.lat, p.lon);
        if (!grid.has(key)) grid.set(key, []);
        grid.get(key).push(i);
      });

      // 4) Recherche de voisins endpoints (progressive)
      setAnalysisProgress(35, 'Recherche de connexions‚Ä¶');
      const connected = new Array(endpoints.length).fill(false);
      const N = endpoints.length;
      for (let i = 0; i < N; i++) {
        const p = endpoints[i];
        const cx = Math.floor(p.lon / deltaLon);
        const cy = Math.floor(p.lat / deltaLat);
        // voisinage 3x3
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            const neighborKey = `${cx + dx},${cy + dy}`;
            const arr = grid.get(neighborKey);
            if (!arr) continue;
            for (const j of arr) {
              if (j === i) continue;
              const q = endpoints[j];
              if (q.id === p.id) continue;
              const d = haversine({lat:p.lat,lon:p.lon}, {lat:q.lat,lon:q.lon});
              if (d <= thresholdMeters) {
                connected[i] = true;
                connected[j] = true;
              }
            }
          }
        }
        if ((i % 500) === 0) {
          setAnalysisProgress(35 + Math.floor(40 * i / N), `Recherche de connexions‚Ä¶ ${i}/${N}`);
          await new Promise(r => setTimeout(r, 0)); // yield
        }
      }

      // 5) Filtre secondaire: endpoint proche d‚Äôun vertex quelconque (r√©duit faux positifs)
      setAnalysisProgress(75, 'Affinage (proximit√© segments)‚Ä¶');
      // Index des vertices de toutes polylines
      const vertexGrid = new Map();
      const verts = [];
      let vcount = 0;
      for (const pl of polylines) {
        for (const pt of pl.geom) {
          const key = cellKey(pt.lat, pt.lon);
          if (!vertexGrid.has(key)) vertexGrid.set(key, []);
          vertexGrid.get(key).push(vcount);
          verts.push(pt);
          vcount++;
        }
      }
      const danglingIdx = [];
      for (let i = 0; i < endpoints.length; i++) {
        if (connected[i]) continue; // d√©j√† connect√©
        const p = endpoints[i];
        const cx = Math.floor(p.lon / deltaLon);
        const cy = Math.floor(p.lat / deltaLat);
        let nearVertex = false;
        for (let dx = -1; dx <= 1 && !nearVertex; dx++) {
          for (let dy = -1; dy <= 1 && !nearVertex; dy++) {
            const key = `${cx + dx},${cy + dy}`;
            const arr = vertexGrid.get(key);
            if (!arr) continue;
            for (const idx of arr) {
              const v = verts[idx];
              const d = haversine({lat:p.lat, lon:p.lon}, v);
              if (d <= thresholdMeters) { nearVertex = true; break; }
            }
          }
        }
        if (!nearVertex) danglingIdx.push(i);
        if ((i % 500) === 0) {
          setAnalysisProgress(75 + Math.floor(20 * i / endpoints.length), `Affinage‚Ä¶ ${i}/${endpoints.length}`);
          await new Promise(r => setTimeout(r, 0));
        }
      }

      // 6) Affichage gaps
      setAnalysisProgress(98, 'Affichage des gaps‚Ä¶');
      gapMarkers.forEach(m => map.removeLayer(m));
      gapMarkers = [];
      for (const idx of danglingIdx) {
        const p = endpoints[idx];
        const m = L.circleMarker([p.lat, p.lon], {
          radius: 6, color: '#dc2626', weight: 2, fillColor: '#ef4444', fillOpacity: 0.9
        }).addTo(map);
        m.bindPopup(`<b>Dangling-end</b><br/>Seuil: ${thresholdMeters} m<br/><small>${p.id}</small>`);
        gapMarkers.push(m);
      }
      gapCount.textContent = String(danglingIdx.length);
      if (gapMarkers.length > 0) {
        const grp = L.featureGroup(gapMarkers);
        zoomGaps.disabled = false;
        // map.fitBounds(grp.getBounds().pad(0.2)); // Laisser l'utilisateur cliquer
      } else {
        zoomGaps.disabled = true;
      }

      setAnalysisProgress(100, 'Analyse termin√©e ‚úîÔ∏è');
    }

    // ---- √âcouteurs ----
    searchButton.addEventListener('click', handleSearch);
    searchInput.addEventListener('keydown', e => { if (e.key === 'Enter') handleSearch(); });

    fitButton.addEventListener('click', () => {
      if (featureLayers.length === 0) return;
      const group = L.featureGroup(featureLayers);
      map.fitBounds(group.getBounds().pad(0.1));
    });
    newSearchButton.addEventListener('click', () => {
      searchPanel.classList.remove('hidden');
      newSearchButton.classList.add('hidden');
      clearLayers();
      resultsCounter.classList.add('hidden');
      errorDisplay.classList.add('hidden');
      analysisPanel.classList.add('hidden');
      setAnalysisProgress(0, 'En attente‚Ä¶');
    });

    startAnalysis.addEventListener('click', runDanglingAnalysis);
    zoomGaps.addEventListener('click', () => {
      if (gapMarkers.length === 0) return;
      const grp = L.featureGroup(gapMarkers);
      map.fitBounds(grp.getBounds().pad(0.2));
    });
    clearGapsBtn.addEventListener('click', () => {
      gapMarkers.forEach(m => map.removeLayer(m));
      gapMarkers = [];
      gapCount.textContent = '0';
      zoomGaps.disabled = true;
      setAnalysisProgress(0, 'En attente‚Ä¶');
    });
  </script>
</body>
</html>
